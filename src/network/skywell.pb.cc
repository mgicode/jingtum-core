// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: skywell.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "skywell.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace protocol {

namespace {

const ::google::protobuf::Descriptor* TMProofWork_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMProofWork_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TMProofWork_PowResult_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TMHello_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMHello_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMClusterNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMClusterNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMLoadSource_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMLoadSource_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMCluster_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMCluster_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMTransaction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMTransaction_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMStatusChange_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMStatusChange_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMProposeSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMProposeSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMHaveTransactionSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMHaveTransactionSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMValidation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMValidation_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMGetPeers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMGetPeers_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMIPv4Endpoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMIPv4Endpoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMPeers_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMPeers_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMEndpoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMEndpoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMEndpoints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMEndpoints_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMIndexedObject_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMIndexedObject_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMGetObjectByHash_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMGetObjectByHash_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TMLedgerNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMLedgerNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMGetLedger_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMGetLedger_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMLedgerData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMLedgerData_reflection_ = NULL;
const ::google::protobuf::Descriptor* TMPing_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TMPing_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TMPing_pingType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TransactionStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* NodeStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* NodeEvent_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TxSetStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TMLedgerInfoType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TMLedgerType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TMQueryType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TMReplyError_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_skywell_2eproto() {
  protobuf_AddDesc_skywell_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "skywell.proto");
  GOOGLE_CHECK(file != NULL);
  TMProofWork_descriptor_ = file->message_type(0);
  static const int TMProofWork_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, iterations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, challenge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, result_),
  };
  TMProofWork_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMProofWork_descriptor_,
      TMProofWork::default_instance_,
      TMProofWork_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProofWork, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMProofWork));
  TMProofWork_PowResult_descriptor_ = TMProofWork_descriptor_->enum_type(0);
  TMHello_descriptor_ = file->message_type(1);
  static const int TMHello_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, protoversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, protoversionmin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, nodepublic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, nodeproof_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, fullversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, nettime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, ipv4port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, ledgerindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, ledgerclosed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, ledgerprevious_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, nodeprivate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, proofofwork_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, testnet_),
  };
  TMHello_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMHello_descriptor_,
      TMHello::default_instance_,
      TMHello_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHello, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMHello));
  TMClusterNode_descriptor_ = file->message_type(2);
  static const int TMClusterNode_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, publickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, reporttime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, nodeload_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, nodename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, address_),
  };
  TMClusterNode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMClusterNode_descriptor_,
      TMClusterNode::default_instance_,
      TMClusterNode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMClusterNode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMClusterNode));
  TMLoadSource_descriptor_ = file->message_type(3);
  static const int TMLoadSource_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLoadSource, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLoadSource, cost_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLoadSource, count_),
  };
  TMLoadSource_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMLoadSource_descriptor_,
      TMLoadSource::default_instance_,
      TMLoadSource_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLoadSource, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLoadSource, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMLoadSource));
  TMCluster_descriptor_ = file->message_type(4);
  static const int TMCluster_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMCluster, clusternodes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMCluster, loadsources_),
  };
  TMCluster_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMCluster_descriptor_,
      TMCluster::default_instance_,
      TMCluster_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMCluster, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMCluster, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMCluster));
  TMTransaction_descriptor_ = file->message_type(5);
  static const int TMTransaction_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMTransaction, rawtransaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMTransaction, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMTransaction, receivetimestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMTransaction, deferred_),
  };
  TMTransaction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMTransaction_descriptor_,
      TMTransaction::default_instance_,
      TMTransaction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMTransaction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMTransaction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMTransaction));
  TMStatusChange_descriptor_ = file->message_type(6);
  static const int TMStatusChange_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, newstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, newevent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, ledgerseq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, ledgerhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, ledgerhashprevious_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, networktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, firstseq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, lastseq_),
  };
  TMStatusChange_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMStatusChange_descriptor_,
      TMStatusChange::default_instance_,
      TMStatusChange_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMStatusChange, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMStatusChange));
  TMProposeSet_descriptor_ = file->message_type(7);
  static const int TMProposeSet_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, proposeseq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, currenttxhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, nodepubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, closetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, previousledger_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, checkedsignature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, addedtransactions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, removedtransactions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, hops_),
  };
  TMProposeSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMProposeSet_descriptor_,
      TMProposeSet::default_instance_,
      TMProposeSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMProposeSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMProposeSet));
  TMHaveTransactionSet_descriptor_ = file->message_type(8);
  static const int TMHaveTransactionSet_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHaveTransactionSet, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHaveTransactionSet, hash_),
  };
  TMHaveTransactionSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMHaveTransactionSet_descriptor_,
      TMHaveTransactionSet::default_instance_,
      TMHaveTransactionSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHaveTransactionSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMHaveTransactionSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMHaveTransactionSet));
  TMValidation_descriptor_ = file->message_type(9);
  static const int TMValidation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMValidation, validation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMValidation, checkedsignature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMValidation, hops_),
  };
  TMValidation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMValidation_descriptor_,
      TMValidation::default_instance_,
      TMValidation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMValidation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMValidation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMValidation));
  TMGetPeers_descriptor_ = file->message_type(10);
  static const int TMGetPeers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetPeers, doweneedthis_),
  };
  TMGetPeers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMGetPeers_descriptor_,
      TMGetPeers::default_instance_,
      TMGetPeers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetPeers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetPeers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMGetPeers));
  TMIPv4Endpoint_descriptor_ = file->message_type(11);
  static const int TMIPv4Endpoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIPv4Endpoint, ipv4_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIPv4Endpoint, ipv4port_),
  };
  TMIPv4Endpoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMIPv4Endpoint_descriptor_,
      TMIPv4Endpoint::default_instance_,
      TMIPv4Endpoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIPv4Endpoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIPv4Endpoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMIPv4Endpoint));
  TMPeers_descriptor_ = file->message_type(12);
  static const int TMPeers_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPeers, nodes_),
  };
  TMPeers_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMPeers_descriptor_,
      TMPeers::default_instance_,
      TMPeers_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPeers, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPeers, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMPeers));
  TMEndpoint_descriptor_ = file->message_type(13);
  static const int TMEndpoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoint, ipv4_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoint, hops_),
  };
  TMEndpoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMEndpoint_descriptor_,
      TMEndpoint::default_instance_,
      TMEndpoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMEndpoint));
  TMEndpoints_descriptor_ = file->message_type(14);
  static const int TMEndpoints_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoints, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoints, endpoints_),
  };
  TMEndpoints_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMEndpoints_descriptor_,
      TMEndpoints::default_instance_,
      TMEndpoints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoints, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMEndpoints, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMEndpoints));
  TMIndexedObject_descriptor_ = file->message_type(15);
  static const int TMIndexedObject_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, nodeid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, ledgerseq_),
  };
  TMIndexedObject_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMIndexedObject_descriptor_,
      TMIndexedObject::default_instance_,
      TMIndexedObject_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMIndexedObject, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMIndexedObject));
  TMGetObjectByHash_descriptor_ = file->message_type(16);
  static const int TMGetObjectByHash_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, query_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, ledgerhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, fat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, objects_),
  };
  TMGetObjectByHash_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMGetObjectByHash_descriptor_,
      TMGetObjectByHash::default_instance_,
      TMGetObjectByHash_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetObjectByHash, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMGetObjectByHash));
  TMGetObjectByHash_ObjectType_descriptor_ = TMGetObjectByHash_descriptor_->enum_type(0);
  TMLedgerNode_descriptor_ = file->message_type(17);
  static const int TMLedgerNode_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerNode, nodedata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerNode, nodeid_),
  };
  TMLedgerNode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMLedgerNode_descriptor_,
      TMLedgerNode::default_instance_,
      TMLedgerNode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerNode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerNode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMLedgerNode));
  TMGetLedger_descriptor_ = file->message_type(18);
  static const int TMGetLedger_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, itype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, ltype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, ledgerhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, ledgerseq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, nodeids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, requestcookie_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, querytype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, querydepth_),
  };
  TMGetLedger_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMGetLedger_descriptor_,
      TMGetLedger::default_instance_,
      TMGetLedger_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMGetLedger, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMGetLedger));
  TMLedgerData_descriptor_ = file->message_type(19);
  static const int TMLedgerData_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, ledgerhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, ledgerseq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, nodes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, requestcookie_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, error_),
  };
  TMLedgerData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMLedgerData_descriptor_,
      TMLedgerData::default_instance_,
      TMLedgerData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMLedgerData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMLedgerData));
  TMPing_descriptor_ = file->message_type(20);
  static const int TMPing_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPing, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPing, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPing, pingtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPing, nettime_),
  };
  TMPing_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TMPing_descriptor_,
      TMPing::default_instance_,
      TMPing_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPing, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TMPing, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TMPing));
  TMPing_pingType_descriptor_ = TMPing_descriptor_->enum_type(0);
  MessageType_descriptor_ = file->enum_type(0);
  TransactionStatus_descriptor_ = file->enum_type(1);
  NodeStatus_descriptor_ = file->enum_type(2);
  NodeEvent_descriptor_ = file->enum_type(3);
  TxSetStatus_descriptor_ = file->enum_type(4);
  TMLedgerInfoType_descriptor_ = file->enum_type(5);
  TMLedgerType_descriptor_ = file->enum_type(6);
  TMQueryType_descriptor_ = file->enum_type(7);
  TMReplyError_descriptor_ = file->enum_type(8);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_skywell_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMProofWork_descriptor_, &TMProofWork::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMHello_descriptor_, &TMHello::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMClusterNode_descriptor_, &TMClusterNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMLoadSource_descriptor_, &TMLoadSource::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMCluster_descriptor_, &TMCluster::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMTransaction_descriptor_, &TMTransaction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMStatusChange_descriptor_, &TMStatusChange::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMProposeSet_descriptor_, &TMProposeSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMHaveTransactionSet_descriptor_, &TMHaveTransactionSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMValidation_descriptor_, &TMValidation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMGetPeers_descriptor_, &TMGetPeers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMIPv4Endpoint_descriptor_, &TMIPv4Endpoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMPeers_descriptor_, &TMPeers::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMEndpoint_descriptor_, &TMEndpoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMEndpoints_descriptor_, &TMEndpoints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMIndexedObject_descriptor_, &TMIndexedObject::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMGetObjectByHash_descriptor_, &TMGetObjectByHash::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMLedgerNode_descriptor_, &TMLedgerNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMGetLedger_descriptor_, &TMGetLedger::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMLedgerData_descriptor_, &TMLedgerData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TMPing_descriptor_, &TMPing::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_skywell_2eproto() {
  delete TMProofWork::default_instance_;
  delete TMProofWork_reflection_;
  delete TMHello::default_instance_;
  delete TMHello_reflection_;
  delete TMClusterNode::default_instance_;
  delete TMClusterNode_reflection_;
  delete TMLoadSource::default_instance_;
  delete TMLoadSource_reflection_;
  delete TMCluster::default_instance_;
  delete TMCluster_reflection_;
  delete TMTransaction::default_instance_;
  delete TMTransaction_reflection_;
  delete TMStatusChange::default_instance_;
  delete TMStatusChange_reflection_;
  delete TMProposeSet::default_instance_;
  delete TMProposeSet_reflection_;
  delete TMHaveTransactionSet::default_instance_;
  delete TMHaveTransactionSet_reflection_;
  delete TMValidation::default_instance_;
  delete TMValidation_reflection_;
  delete TMGetPeers::default_instance_;
  delete TMGetPeers_reflection_;
  delete TMIPv4Endpoint::default_instance_;
  delete TMIPv4Endpoint_reflection_;
  delete TMPeers::default_instance_;
  delete TMPeers_reflection_;
  delete TMEndpoint::default_instance_;
  delete TMEndpoint_reflection_;
  delete TMEndpoints::default_instance_;
  delete TMEndpoints_reflection_;
  delete TMIndexedObject::default_instance_;
  delete TMIndexedObject_reflection_;
  delete TMGetObjectByHash::default_instance_;
  delete TMGetObjectByHash_reflection_;
  delete TMLedgerNode::default_instance_;
  delete TMLedgerNode_reflection_;
  delete TMGetLedger::default_instance_;
  delete TMGetLedger_reflection_;
  delete TMLedgerData::default_instance_;
  delete TMLedgerData_reflection_;
  delete TMPing::default_instance_;
  delete TMPing_reflection_;
}

void protobuf_AddDesc_skywell_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rskywell.proto\022\010protocol\"\206\002\n\013TMProofWor"
    "k\022\r\n\005token\030\001 \002(\t\022\022\n\niterations\030\002 \001(\r\022\016\n\006"
    "target\030\003 \001(\014\022\021\n\tchallenge\030\004 \001(\014\022\020\n\010respo"
    "nse\030\005 \001(\014\022/\n\006result\030\006 \001(\0162\037.protocol.TMP"
    "roofWork.PowResult\"n\n\tPowResult\022\n\n\006powrO"
    "K\020\000\022\016\n\npowrREUSED\020\001\022\017\n\013powrEXPIRED\020\002\022\017\n\013"
    "powrTOOEASY\020\003\022\017\n\013powrINVALID\020\004\022\022\n\016powrDI"
    "SCONNECT\020\005\"\254\002\n\007TMHello\022\024\n\014protoVersion\030\001"
    " \002(\r\022\027\n\017protoVersionMin\030\002 \002(\r\022\022\n\nnodePub"
    "lic\030\003 \002(\014\022\021\n\tnodeProof\030\004 \002(\014\022\023\n\013fullVers"
    "ion\030\005 \001(\t\022\017\n\007netTime\030\006 \001(\004\022\020\n\010ipv4Port\030\007"
    " \001(\r\022\023\n\013ledgerIndex\030\010 \001(\r\022\024\n\014ledgerClose"
    "d\030\t \001(\014\022\026\n\016ledgerPrevious\030\n \001(\014\022\023\n\013nodeP"
    "rivate\030\013 \001(\010\022*\n\013proofOfWork\030\014 \001(\0132\025.prot"
    "ocol.TMProofWork\022\017\n\007testNet\030\r \001(\010\"k\n\rTMC"
    "lusterNode\022\021\n\tpublicKey\030\001 \002(\t\022\022\n\nreportT"
    "ime\030\002 \002(\r\022\020\n\010nodeLoad\030\003 \002(\r\022\020\n\010nodeName\030"
    "\004 \001(\t\022\017\n\007address\030\005 \001(\t\"9\n\014TMLoadSource\022\014"
    "\n\004name\030\001 \002(\t\022\014\n\004cost\030\002 \002(\r\022\r\n\005count\030\003 \001("
    "\r\"g\n\tTMCluster\022-\n\014clusterNodes\030\001 \003(\0132\027.p"
    "rotocol.TMClusterNode\022+\n\013loadSources\030\002 \003"
    "(\0132\026.protocol.TMLoadSource\"\200\001\n\rTMTransac"
    "tion\022\026\n\016rawTransaction\030\001 \002(\014\022+\n\006status\030\002"
    " \002(\0162\033.protocol.TransactionStatus\022\030\n\020rec"
    "eiveTimestamp\030\003 \001(\004\022\020\n\010deferred\030\004 \001(\010\"\333\001"
    "\n\016TMStatusChange\022\'\n\tnewStatus\030\001 \001(\0162\024.pr"
    "otocol.NodeStatus\022%\n\010newEvent\030\002 \001(\0162\023.pr"
    "otocol.NodeEvent\022\021\n\tledgerSeq\030\003 \001(\r\022\022\n\nl"
    "edgerHash\030\004 \001(\014\022\032\n\022ledgerHashPrevious\030\005 "
    "\001(\014\022\023\n\013networkTime\030\006 \001(\004\022\020\n\010firstSeq\030\007 \001"
    "(\r\022\017\n\007lastSeq\030\010 \001(\r\"\353\001\n\014TMProposeSet\022\022\n\n"
    "proposeSeq\030\001 \002(\r\022\025\n\rcurrentTxHash\030\002 \002(\014\022"
    "\022\n\nnodePubKey\030\003 \002(\014\022\021\n\tcloseTime\030\004 \002(\r\022\021"
    "\n\tsignature\030\005 \002(\014\022\026\n\016previousledger\030\006 \001("
    "\014\022\030\n\020checkedSignature\030\007 \001(\010\022\031\n\021addedTran"
    "sactions\030\n \003(\014\022\033\n\023removedTransactions\030\013 "
    "\003(\014\022\014\n\004hops\030\014 \001(\r\"K\n\024TMHaveTransactionSe"
    "t\022%\n\006status\030\001 \002(\0162\025.protocol.TxSetStatus"
    "\022\014\n\004hash\030\002 \002(\014\"J\n\014TMValidation\022\022\n\nvalida"
    "tion\030\001 \002(\014\022\030\n\020checkedSignature\030\002 \001(\010\022\014\n\004"
    "hops\030\003 \001(\r\"\"\n\nTMGetPeers\022\024\n\014doWeNeedThis"
    "\030\001 \002(\r\"0\n\016TMIPv4Endpoint\022\014\n\004ipv4\030\001 \002(\r\022\020"
    "\n\010ipv4Port\030\002 \002(\r\"2\n\007TMPeers\022\'\n\005nodes\030\001 \003"
    "(\0132\030.protocol.TMIPv4Endpoint\"B\n\nTMEndpoi"
    "nt\022&\n\004ipv4\030\001 \002(\0132\030.protocol.TMIPv4Endpoi"
    "nt\022\014\n\004hops\030\002 \002(\r\"G\n\013TMEndpoints\022\017\n\007versi"
    "on\030\001 \002(\r\022\'\n\tendpoints\030\002 \003(\0132\024.protocol.T"
    "MEndpoint\"_\n\017TMIndexedObject\022\014\n\004hash\030\001 \001"
    "(\014\022\016\n\006nodeID\030\002 \001(\014\022\r\n\005index\030\003 \001(\014\022\014\n\004dat"
    "a\030\004 \001(\014\022\021\n\tledgerSeq\030\005 \001(\r\"\277\002\n\021TMGetObje"
    "ctByHash\0224\n\004type\030\001 \002(\0162&.protocol.TMGetO"
    "bjectByHash.ObjectType\022\r\n\005query\030\002 \002(\010\022\013\n"
    "\003seq\030\003 \001(\r\022\022\n\nledgerHash\030\004 \001(\014\022\013\n\003fat\030\005 "
    "\001(\010\022*\n\007objects\030\006 \003(\0132\031.protocol.TMIndexe"
    "dObject\"\212\001\n\nObjectType\022\r\n\totUNKNOWN\020\000\022\014\n"
    "\010otLEDGER\020\001\022\021\n\rotTRANSACTION\020\002\022\026\n\022otTRAN"
    "SACTION_NODE\020\003\022\020\n\014otSTATE_NODE\020\004\022\020\n\014otCA"
    "S_OBJECT\020\005\022\020\n\014otFETCH_PACK\020\006\"0\n\014TMLedger"
    "Node\022\020\n\010nodedata\030\001 \002(\014\022\016\n\006nodeid\030\002 \001(\014\"\354"
    "\001\n\013TMGetLedger\022)\n\005itype\030\001 \002(\0162\032.protocol"
    ".TMLedgerInfoType\022%\n\005ltype\030\002 \001(\0162\026.proto"
    "col.TMLedgerType\022\022\n\nledgerHash\030\003 \001(\014\022\021\n\t"
    "ledgerSeq\030\004 \001(\r\022\017\n\007nodeIDs\030\005 \003(\014\022\025\n\rrequ"
    "estCookie\030\006 \001(\004\022(\n\tqueryType\030\007 \001(\0162\025.pro"
    "tocol.TMQueryType\022\022\n\nqueryDepth\030\010 \001(\r\"\304\001"
    "\n\014TMLedgerData\022\022\n\nledgerHash\030\001 \002(\014\022\021\n\tle"
    "dgerSeq\030\002 \002(\r\022(\n\004type\030\003 \002(\0162\032.protocol.T"
    "MLedgerInfoType\022%\n\005nodes\030\004 \003(\0132\026.protoco"
    "l.TMLedgerNode\022\025\n\rrequestCookie\030\005 \001(\r\022%\n"
    "\005error\030\006 \001(\0162\026.protocol.TMReplyError\"\205\001\n"
    "\006TMPing\022\'\n\004type\030\001 \002(\0162\031.protocol.TMPing."
    "pingType\022\013\n\003seq\030\002 \001(\r\022\020\n\010pingTime\030\003 \001(\004\022"
    "\017\n\007netTime\030\004 \001(\004\"\"\n\010pingType\022\n\n\006ptPING\020\000"
    "\022\n\n\006ptPONG\020\001*\217\002\n\013MessageType\022\013\n\007mtHELLO\020"
    "\001\022\n\n\006mtPING\020\003\022\021\n\rmtPROOFOFWORK\020\004\022\r\n\tmtCL"
    "USTER\020\005\022\017\n\013mtGET_PEERS\020\014\022\013\n\007mtPEERS\020\r\022\017\n"
    "\013mtENDPOINTS\020\017\022\021\n\rmtTRANSACTION\020\036\022\020\n\014mtG"
    "ET_LEDGER\020\037\022\021\n\rmtLEDGER_DATA\020 \022\024\n\020mtPROP"
    "OSE_LEDGER\020!\022\023\n\017mtSTATUS_CHANGE\020\"\022\016\n\nmtH"
    "AVE_SET\020#\022\020\n\014mtVALIDATION\020)\022\021\n\rmtGET_OBJ"
    "ECTS\020**\241\001\n\021TransactionStatus\022\t\n\005tsNEW\020\001\022"
    "\r\n\ttsCURRENT\020\002\022\016\n\ntsCOMMITED\020\003\022\025\n\021tsREJE"
    "CT_CONFLICT\020\004\022\024\n\020tsREJECT_INVALID\020\005\022\022\n\016t"
    "sREJECT_FUNDS\020\006\022\016\n\ntsHELD_SEQ\020\007\022\021\n\rtsHEL"
    "D_LEDGER\020\010*c\n\nNodeStatus\022\020\n\014nsCONNECTING"
    "\020\001\022\017\n\013nsCONNECTED\020\002\022\020\n\014nsMONITORING\020\003\022\020\n"
    "\014nsVALIDATING\020\004\022\016\n\nnsSHUTTING\020\005*`\n\tNodeE"
    "vent\022\024\n\020neCLOSING_LEDGER\020\001\022\025\n\021neACCEPTED"
    "_LEDGER\020\002\022\025\n\021neSWITCHED_LEDGER\020\003\022\017\n\013neLO"
    "ST_SYNC\020\004*4\n\013TxSetStatus\022\n\n\006tsHAVE\020\001\022\r\n\t"
    "tsCAN_GET\020\002\022\n\n\006tsNEED\020\003*P\n\020TMLedgerInfoT"
    "ype\022\n\n\006liBASE\020\000\022\r\n\tliTX_NODE\020\001\022\r\n\tliAS_N"
    "ODE\020\002\022\022\n\016liTS_CANDIDATE\020\003*;\n\014TMLedgerTyp"
    "e\022\016\n\nltACCEPTED\020\000\022\r\n\tltCURRENT\020\001\022\014\n\010ltCL"
    "OSED\020\002*\035\n\013TMQueryType\022\016\n\nqtINDIRECT\020\000*.\n"
    "\014TMReplyError\022\017\n\013reNO_LEDGER\020\001\022\r\n\treNO_N"
    "ODE\020\002", 3845);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "skywell.proto", &protobuf_RegisterTypes);
  TMProofWork::default_instance_ = new TMProofWork();
  TMHello::default_instance_ = new TMHello();
  TMClusterNode::default_instance_ = new TMClusterNode();
  TMLoadSource::default_instance_ = new TMLoadSource();
  TMCluster::default_instance_ = new TMCluster();
  TMTransaction::default_instance_ = new TMTransaction();
  TMStatusChange::default_instance_ = new TMStatusChange();
  TMProposeSet::default_instance_ = new TMProposeSet();
  TMHaveTransactionSet::default_instance_ = new TMHaveTransactionSet();
  TMValidation::default_instance_ = new TMValidation();
  TMGetPeers::default_instance_ = new TMGetPeers();
  TMIPv4Endpoint::default_instance_ = new TMIPv4Endpoint();
  TMPeers::default_instance_ = new TMPeers();
  TMEndpoint::default_instance_ = new TMEndpoint();
  TMEndpoints::default_instance_ = new TMEndpoints();
  TMIndexedObject::default_instance_ = new TMIndexedObject();
  TMGetObjectByHash::default_instance_ = new TMGetObjectByHash();
  TMLedgerNode::default_instance_ = new TMLedgerNode();
  TMGetLedger::default_instance_ = new TMGetLedger();
  TMLedgerData::default_instance_ = new TMLedgerData();
  TMPing::default_instance_ = new TMPing();
  TMProofWork::default_instance_->InitAsDefaultInstance();
  TMHello::default_instance_->InitAsDefaultInstance();
  TMClusterNode::default_instance_->InitAsDefaultInstance();
  TMLoadSource::default_instance_->InitAsDefaultInstance();
  TMCluster::default_instance_->InitAsDefaultInstance();
  TMTransaction::default_instance_->InitAsDefaultInstance();
  TMStatusChange::default_instance_->InitAsDefaultInstance();
  TMProposeSet::default_instance_->InitAsDefaultInstance();
  TMHaveTransactionSet::default_instance_->InitAsDefaultInstance();
  TMValidation::default_instance_->InitAsDefaultInstance();
  TMGetPeers::default_instance_->InitAsDefaultInstance();
  TMIPv4Endpoint::default_instance_->InitAsDefaultInstance();
  TMPeers::default_instance_->InitAsDefaultInstance();
  TMEndpoint::default_instance_->InitAsDefaultInstance();
  TMEndpoints::default_instance_->InitAsDefaultInstance();
  TMIndexedObject::default_instance_->InitAsDefaultInstance();
  TMGetObjectByHash::default_instance_->InitAsDefaultInstance();
  TMLedgerNode::default_instance_->InitAsDefaultInstance();
  TMGetLedger::default_instance_->InitAsDefaultInstance();
  TMLedgerData::default_instance_->InitAsDefaultInstance();
  TMPing::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_skywell_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_skywell_2eproto {
  StaticDescriptorInitializer_skywell_2eproto() {
    protobuf_AddDesc_skywell_2eproto();
  }
} static_descriptor_initializer_skywell_2eproto_;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 1:
    case 3:
    case 4:
    case 5:
    case 12:
    case 13:
    case 15:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TransactionStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionStatus_descriptor_;
}
bool TransactionStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* NodeStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeStatus_descriptor_;
}
bool NodeStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* NodeEvent_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeEvent_descriptor_;
}
bool NodeEvent_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TxSetStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxSetStatus_descriptor_;
}
bool TxSetStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMLedgerInfoType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMLedgerInfoType_descriptor_;
}
bool TMLedgerInfoType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMLedgerType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMLedgerType_descriptor_;
}
bool TMLedgerType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMQueryType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMQueryType_descriptor_;
}
bool TMQueryType_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMReplyError_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMReplyError_descriptor_;
}
bool TMReplyError_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TMProofWork_PowResult_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMProofWork_PowResult_descriptor_;
}
bool TMProofWork_PowResult_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TMProofWork_PowResult TMProofWork::powrOK;
const TMProofWork_PowResult TMProofWork::powrREUSED;
const TMProofWork_PowResult TMProofWork::powrEXPIRED;
const TMProofWork_PowResult TMProofWork::powrTOOEASY;
const TMProofWork_PowResult TMProofWork::powrINVALID;
const TMProofWork_PowResult TMProofWork::powrDISCONNECT;
const TMProofWork_PowResult TMProofWork::PowResult_MIN;
const TMProofWork_PowResult TMProofWork::PowResult_MAX;
const int TMProofWork::PowResult_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TMProofWork::kTokenFieldNumber;
const int TMProofWork::kIterationsFieldNumber;
const int TMProofWork::kTargetFieldNumber;
const int TMProofWork::kChallengeFieldNumber;
const int TMProofWork::kResponseFieldNumber;
const int TMProofWork::kResultFieldNumber;
#endif  // !_MSC_VER

TMProofWork::TMProofWork()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMProofWork::InitAsDefaultInstance() {
}

TMProofWork::TMProofWork(const TMProofWork& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMProofWork::SharedCtor() {
  _cached_size_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iterations_ = 0u;
  target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMProofWork::~TMProofWork() {
  SharedDtor();
}

void TMProofWork::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    delete response_;
  }
  if (this != default_instance_) {
  }
}

void TMProofWork::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMProofWork::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMProofWork_descriptor_;
}

const TMProofWork& TMProofWork::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMProofWork* TMProofWork::default_instance_ = NULL;

TMProofWork* TMProofWork::New() const {
  return new TMProofWork;
}

void TMProofWork::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    iterations_ = 0u;
    if (has_target()) {
      if (target_ != &::google::protobuf::internal::kEmptyString) {
        target_->clear();
      }
    }
    if (has_challenge()) {
      if (challenge_ != &::google::protobuf::internal::kEmptyString) {
        challenge_->clear();
      }
    }
    if (has_response()) {
      if (response_ != &::google::protobuf::internal::kEmptyString) {
        response_->clear();
      }
    }
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMProofWork::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->token().data(), this->token().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_iterations;
        break;
      }

      // optional uint32 iterations = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_iterations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &iterations_)));
          set_has_iterations();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_target;
        break;
      }

      // optional bytes target = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_challenge;
        break;
      }

      // optional bytes challenge = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_challenge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_challenge()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_response;
        break;
      }

      // optional bytes response = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_result;
        break;
      }

      // optional .protocol.TMProofWork.PowResult result = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMProofWork_PowResult_IsValid(value)) {
            set_result(static_cast< ::protocol::TMProofWork_PowResult >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMProofWork::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->token(), output);
  }

  // optional uint32 iterations = 2;
  if (has_iterations()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->iterations(), output);
  }

  // optional bytes target = 3;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->target(), output);
  }

  // optional bytes challenge = 4;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->challenge(), output);
  }

  // optional bytes response = 5;
  if (has_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->response(), output);
  }

  // optional .protocol.TMProofWork.PowResult result = 6;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->result(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMProofWork::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->token(), target);
  }

  // optional uint32 iterations = 2;
  if (has_iterations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->iterations(), target);
  }

  // optional bytes target = 3;
  if (has_target()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->target(), target);
  }

  // optional bytes challenge = 4;
  if (has_challenge()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->challenge(), target);
  }

  // optional bytes response = 5;
  if (has_response()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->response(), target);
  }

  // optional .protocol.TMProofWork.PowResult result = 6;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->result(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMProofWork::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // optional uint32 iterations = 2;
    if (has_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->iterations());
    }

    // optional bytes target = 3;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target());
    }

    // optional bytes challenge = 4;
    if (has_challenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->challenge());
    }

    // optional bytes response = 5;
    if (has_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->response());
    }

    // optional .protocol.TMProofWork.PowResult result = 6;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMProofWork::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMProofWork* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMProofWork*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMProofWork::MergeFrom(const TMProofWork& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_iterations()) {
      set_iterations(from.iterations());
    }
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_challenge()) {
      set_challenge(from.challenge());
    }
    if (from.has_response()) {
      set_response(from.response());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMProofWork::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProofWork::CopyFrom(const TMProofWork& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofWork::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TMProofWork::Swap(TMProofWork* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(iterations_, other->iterations_);
    std::swap(target_, other->target_);
    std::swap(challenge_, other->challenge_);
    std::swap(response_, other->response_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMProofWork::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMProofWork_descriptor_;
  metadata.reflection = TMProofWork_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMHello::kProtoVersionFieldNumber;
const int TMHello::kProtoVersionMinFieldNumber;
const int TMHello::kNodePublicFieldNumber;
const int TMHello::kNodeProofFieldNumber;
const int TMHello::kFullVersionFieldNumber;
const int TMHello::kNetTimeFieldNumber;
const int TMHello::kIpv4PortFieldNumber;
const int TMHello::kLedgerIndexFieldNumber;
const int TMHello::kLedgerClosedFieldNumber;
const int TMHello::kLedgerPreviousFieldNumber;
const int TMHello::kNodePrivateFieldNumber;
const int TMHello::kProofOfWorkFieldNumber;
const int TMHello::kTestNetFieldNumber;
#endif  // !_MSC_VER

TMHello::TMHello()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMHello::InitAsDefaultInstance() {
  proofofwork_ = const_cast< ::protocol::TMProofWork*>(&::protocol::TMProofWork::default_instance());
}

TMHello::TMHello(const TMHello& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMHello::SharedCtor() {
  _cached_size_ = 0;
  protoversion_ = 0u;
  protoversionmin_ = 0u;
  nodepublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nodeproof_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fullversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nettime_ = GOOGLE_ULONGLONG(0);
  ipv4port_ = 0u;
  ledgerindex_ = 0u;
  ledgerclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ledgerprevious_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nodeprivate_ = false;
  proofofwork_ = NULL;
  testnet_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMHello::~TMHello() {
  SharedDtor();
}

void TMHello::SharedDtor() {
  if (nodepublic_ != &::google::protobuf::internal::kEmptyString) {
    delete nodepublic_;
  }
  if (nodeproof_ != &::google::protobuf::internal::kEmptyString) {
    delete nodeproof_;
  }
  if (fullversion_ != &::google::protobuf::internal::kEmptyString) {
    delete fullversion_;
  }
  if (ledgerclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerclosed_;
  }
  if (ledgerprevious_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerprevious_;
  }
  if (this != default_instance_) {
    delete proofofwork_;
  }
}

void TMHello::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMHello::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMHello_descriptor_;
}

const TMHello& TMHello::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMHello* TMHello::default_instance_ = NULL;

TMHello* TMHello::New() const {
  return new TMHello;
}

void TMHello::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    protoversion_ = 0u;
    protoversionmin_ = 0u;
    if (has_nodepublic()) {
      if (nodepublic_ != &::google::protobuf::internal::kEmptyString) {
        nodepublic_->clear();
      }
    }
    if (has_nodeproof()) {
      if (nodeproof_ != &::google::protobuf::internal::kEmptyString) {
        nodeproof_->clear();
      }
    }
    if (has_fullversion()) {
      if (fullversion_ != &::google::protobuf::internal::kEmptyString) {
        fullversion_->clear();
      }
    }
    nettime_ = GOOGLE_ULONGLONG(0);
    ipv4port_ = 0u;
    ledgerindex_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_ledgerclosed()) {
      if (ledgerclosed_ != &::google::protobuf::internal::kEmptyString) {
        ledgerclosed_->clear();
      }
    }
    if (has_ledgerprevious()) {
      if (ledgerprevious_ != &::google::protobuf::internal::kEmptyString) {
        ledgerprevious_->clear();
      }
    }
    nodeprivate_ = false;
    if (has_proofofwork()) {
      if (proofofwork_ != NULL) proofofwork_->::protocol::TMProofWork::Clear();
    }
    testnet_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMHello::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 protoVersion = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protoversion_)));
          set_has_protoversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_protoVersionMin;
        break;
      }

      // required uint32 protoVersionMin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_protoVersionMin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protoversionmin_)));
          set_has_protoversionmin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_nodePublic;
        break;
      }

      // required bytes nodePublic = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodePublic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepublic()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nodeProof;
        break;
      }

      // required bytes nodeProof = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodeProof:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeproof()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_fullVersion;
        break;
      }

      // optional string fullVersion = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fullVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fullversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->fullversion().data(), this->fullversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_netTime;
        break;
      }

      // optional uint64 netTime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_netTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nettime_)));
          set_has_nettime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_ipv4Port;
        break;
      }

      // optional uint32 ipv4Port = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ipv4Port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipv4port_)));
          set_has_ipv4port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_ledgerIndex;
        break;
      }

      // optional uint32 ledgerIndex = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ledgerIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerindex_)));
          set_has_ledgerindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_ledgerClosed;
        break;
      }

      // optional bytes ledgerClosed = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ledgerClosed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerclosed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_ledgerPrevious;
        break;
      }

      // optional bytes ledgerPrevious = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ledgerPrevious:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerprevious()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_nodePrivate;
        break;
      }

      // optional bool nodePrivate = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nodePrivate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nodeprivate_)));
          set_has_nodeprivate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_proofOfWork;
        break;
      }

      // optional .protocol.TMProofWork proofOfWork = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proofOfWork:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_proofofwork()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_testNet;
        break;
      }

      // optional bool testNet = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_testNet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &testnet_)));
          set_has_testnet();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMHello::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 protoVersion = 1;
  if (has_protoversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->protoversion(), output);
  }

  // required uint32 protoVersionMin = 2;
  if (has_protoversionmin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->protoversionmin(), output);
  }

  // required bytes nodePublic = 3;
  if (has_nodepublic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->nodepublic(), output);
  }

  // required bytes nodeProof = 4;
  if (has_nodeproof()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->nodeproof(), output);
  }

  // optional string fullVersion = 5;
  if (has_fullversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->fullversion().data(), this->fullversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->fullversion(), output);
  }

  // optional uint64 netTime = 6;
  if (has_nettime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->nettime(), output);
  }

  // optional uint32 ipv4Port = 7;
  if (has_ipv4port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->ipv4port(), output);
  }

  // optional uint32 ledgerIndex = 8;
  if (has_ledgerindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->ledgerindex(), output);
  }

  // optional bytes ledgerClosed = 9;
  if (has_ledgerclosed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->ledgerclosed(), output);
  }

  // optional bytes ledgerPrevious = 10;
  if (has_ledgerprevious()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->ledgerprevious(), output);
  }

  // optional bool nodePrivate = 11;
  if (has_nodeprivate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->nodeprivate(), output);
  }

  // optional .protocol.TMProofWork proofOfWork = 12;
  if (has_proofofwork()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->proofofwork(), output);
  }

  // optional bool testNet = 13;
  if (has_testnet()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->testnet(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMHello::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 protoVersion = 1;
  if (has_protoversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->protoversion(), target);
  }

  // required uint32 protoVersionMin = 2;
  if (has_protoversionmin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->protoversionmin(), target);
  }

  // required bytes nodePublic = 3;
  if (has_nodepublic()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nodepublic(), target);
  }

  // required bytes nodeProof = 4;
  if (has_nodeproof()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->nodeproof(), target);
  }

  // optional string fullVersion = 5;
  if (has_fullversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->fullversion().data(), this->fullversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->fullversion(), target);
  }

  // optional uint64 netTime = 6;
  if (has_nettime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->nettime(), target);
  }

  // optional uint32 ipv4Port = 7;
  if (has_ipv4port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->ipv4port(), target);
  }

  // optional uint32 ledgerIndex = 8;
  if (has_ledgerindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->ledgerindex(), target);
  }

  // optional bytes ledgerClosed = 9;
  if (has_ledgerclosed()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->ledgerclosed(), target);
  }

  // optional bytes ledgerPrevious = 10;
  if (has_ledgerprevious()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->ledgerprevious(), target);
  }

  // optional bool nodePrivate = 11;
  if (has_nodeprivate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->nodeprivate(), target);
  }

  // optional .protocol.TMProofWork proofOfWork = 12;
  if (has_proofofwork()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->proofofwork(), target);
  }

  // optional bool testNet = 13;
  if (has_testnet()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->testnet(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMHello::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 protoVersion = 1;
    if (has_protoversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->protoversion());
    }

    // required uint32 protoVersionMin = 2;
    if (has_protoversionmin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->protoversionmin());
    }

    // required bytes nodePublic = 3;
    if (has_nodepublic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodepublic());
    }

    // required bytes nodeProof = 4;
    if (has_nodeproof()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodeproof());
    }

    // optional string fullVersion = 5;
    if (has_fullversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fullversion());
    }

    // optional uint64 netTime = 6;
    if (has_nettime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nettime());
    }

    // optional uint32 ipv4Port = 7;
    if (has_ipv4port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ipv4port());
    }

    // optional uint32 ledgerIndex = 8;
    if (has_ledgerindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerindex());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes ledgerClosed = 9;
    if (has_ledgerclosed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerclosed());
    }

    // optional bytes ledgerPrevious = 10;
    if (has_ledgerprevious()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerprevious());
    }

    // optional bool nodePrivate = 11;
    if (has_nodeprivate()) {
      total_size += 1 + 1;
    }

    // optional .protocol.TMProofWork proofOfWork = 12;
    if (has_proofofwork()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->proofofwork());
    }

    // optional bool testNet = 13;
    if (has_testnet()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMHello::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMHello* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMHello*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMHello::MergeFrom(const TMHello& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protoversion()) {
      set_protoversion(from.protoversion());
    }
    if (from.has_protoversionmin()) {
      set_protoversionmin(from.protoversionmin());
    }
    if (from.has_nodepublic()) {
      set_nodepublic(from.nodepublic());
    }
    if (from.has_nodeproof()) {
      set_nodeproof(from.nodeproof());
    }
    if (from.has_fullversion()) {
      set_fullversion(from.fullversion());
    }
    if (from.has_nettime()) {
      set_nettime(from.nettime());
    }
    if (from.has_ipv4port()) {
      set_ipv4port(from.ipv4port());
    }
    if (from.has_ledgerindex()) {
      set_ledgerindex(from.ledgerindex());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ledgerclosed()) {
      set_ledgerclosed(from.ledgerclosed());
    }
    if (from.has_ledgerprevious()) {
      set_ledgerprevious(from.ledgerprevious());
    }
    if (from.has_nodeprivate()) {
      set_nodeprivate(from.nodeprivate());
    }
    if (from.has_proofofwork()) {
      mutable_proofofwork()->::protocol::TMProofWork::MergeFrom(from.proofofwork());
    }
    if (from.has_testnet()) {
      set_testnet(from.testnet());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMHello::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHello::CopyFrom(const TMHello& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHello::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_proofofwork()) {
    if (!this->proofofwork().IsInitialized()) return false;
  }
  return true;
}

void TMHello::Swap(TMHello* other) {
  if (other != this) {
    std::swap(protoversion_, other->protoversion_);
    std::swap(protoversionmin_, other->protoversionmin_);
    std::swap(nodepublic_, other->nodepublic_);
    std::swap(nodeproof_, other->nodeproof_);
    std::swap(fullversion_, other->fullversion_);
    std::swap(nettime_, other->nettime_);
    std::swap(ipv4port_, other->ipv4port_);
    std::swap(ledgerindex_, other->ledgerindex_);
    std::swap(ledgerclosed_, other->ledgerclosed_);
    std::swap(ledgerprevious_, other->ledgerprevious_);
    std::swap(nodeprivate_, other->nodeprivate_);
    std::swap(proofofwork_, other->proofofwork_);
    std::swap(testnet_, other->testnet_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMHello::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMHello_descriptor_;
  metadata.reflection = TMHello_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMClusterNode::kPublicKeyFieldNumber;
const int TMClusterNode::kReportTimeFieldNumber;
const int TMClusterNode::kNodeLoadFieldNumber;
const int TMClusterNode::kNodeNameFieldNumber;
const int TMClusterNode::kAddressFieldNumber;
#endif  // !_MSC_VER

TMClusterNode::TMClusterNode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMClusterNode::InitAsDefaultInstance() {
}

TMClusterNode::TMClusterNode(const TMClusterNode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMClusterNode::SharedCtor() {
  _cached_size_ = 0;
  publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reporttime_ = 0u;
  nodeload_ = 0u;
  nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMClusterNode::~TMClusterNode() {
  SharedDtor();
}

void TMClusterNode::SharedDtor() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    delete nodename_;
  }
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void TMClusterNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMClusterNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMClusterNode_descriptor_;
}

const TMClusterNode& TMClusterNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMClusterNode* TMClusterNode::default_instance_ = NULL;

TMClusterNode* TMClusterNode::New() const {
  return new TMClusterNode;
}

void TMClusterNode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_publickey()) {
      if (publickey_ != &::google::protobuf::internal::kEmptyString) {
        publickey_->clear();
      }
    }
    reporttime_ = 0u;
    nodeload_ = 0u;
    if (has_nodename()) {
      if (nodename_ != &::google::protobuf::internal::kEmptyString) {
        nodename_->clear();
      }
    }
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMClusterNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string publicKey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_publickey()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->publickey().data(), this->publickey().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_reportTime;
        break;
      }

      // required uint32 reportTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reportTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reporttime_)));
          set_has_reporttime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nodeLoad;
        break;
      }

      // required uint32 nodeLoad = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nodeLoad:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nodeload_)));
          set_has_nodeload();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nodeName;
        break;
      }

      // optional string nodeName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodeName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nodename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->nodename().data(), this->nodename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_address;
        break;
      }

      // optional string address = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMClusterNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string publicKey = 1;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->publickey().data(), this->publickey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->publickey(), output);
  }

  // required uint32 reportTime = 2;
  if (has_reporttime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->reporttime(), output);
  }

  // required uint32 nodeLoad = 3;
  if (has_nodeload()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nodeload(), output);
  }

  // optional string nodeName = 4;
  if (has_nodename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->nodename().data(), this->nodename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->nodename(), output);
  }

  // optional string address = 5;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMClusterNode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string publicKey = 1;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->publickey().data(), this->publickey().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->publickey(), target);
  }

  // required uint32 reportTime = 2;
  if (has_reporttime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->reporttime(), target);
  }

  // required uint32 nodeLoad = 3;
  if (has_nodeload()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->nodeload(), target);
  }

  // optional string nodeName = 4;
  if (has_nodename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->nodename().data(), this->nodename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->nodename(), target);
  }

  // optional string address = 5;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMClusterNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string publicKey = 1;
    if (has_publickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->publickey());
    }

    // required uint32 reportTime = 2;
    if (has_reporttime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reporttime());
    }

    // required uint32 nodeLoad = 3;
    if (has_nodeload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nodeload());
    }

    // optional string nodeName = 4;
    if (has_nodename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nodename());
    }

    // optional string address = 5;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMClusterNode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMClusterNode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMClusterNode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMClusterNode::MergeFrom(const TMClusterNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_publickey()) {
      set_publickey(from.publickey());
    }
    if (from.has_reporttime()) {
      set_reporttime(from.reporttime());
    }
    if (from.has_nodeload()) {
      set_nodeload(from.nodeload());
    }
    if (from.has_nodename()) {
      set_nodename(from.nodename());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMClusterNode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMClusterNode::CopyFrom(const TMClusterNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMClusterNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void TMClusterNode::Swap(TMClusterNode* other) {
  if (other != this) {
    std::swap(publickey_, other->publickey_);
    std::swap(reporttime_, other->reporttime_);
    std::swap(nodeload_, other->nodeload_);
    std::swap(nodename_, other->nodename_);
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMClusterNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMClusterNode_descriptor_;
  metadata.reflection = TMClusterNode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMLoadSource::kNameFieldNumber;
const int TMLoadSource::kCostFieldNumber;
const int TMLoadSource::kCountFieldNumber;
#endif  // !_MSC_VER

TMLoadSource::TMLoadSource()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMLoadSource::InitAsDefaultInstance() {
}

TMLoadSource::TMLoadSource(const TMLoadSource& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMLoadSource::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cost_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMLoadSource::~TMLoadSource() {
  SharedDtor();
}

void TMLoadSource::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void TMLoadSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMLoadSource::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMLoadSource_descriptor_;
}

const TMLoadSource& TMLoadSource::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMLoadSource* TMLoadSource::default_instance_ = NULL;

TMLoadSource* TMLoadSource::New() const {
  return new TMLoadSource;
}

void TMLoadSource::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    cost_ = 0u;
    count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMLoadSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cost;
        break;
      }

      // required uint32 cost = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_)));
          set_has_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // optional uint32 count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMLoadSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint32 cost = 2;
  if (has_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cost(), output);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMLoadSource::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 cost = 2;
  if (has_cost()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cost(), target);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMLoadSource::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 cost = 2;
    if (has_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cost());
    }

    // optional uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMLoadSource::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMLoadSource* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMLoadSource*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMLoadSource::MergeFrom(const TMLoadSource& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_cost()) {
      set_cost(from.cost());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMLoadSource::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLoadSource::CopyFrom(const TMLoadSource& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLoadSource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TMLoadSource::Swap(TMLoadSource* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(cost_, other->cost_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMLoadSource::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMLoadSource_descriptor_;
  metadata.reflection = TMLoadSource_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMCluster::kClusterNodesFieldNumber;
const int TMCluster::kLoadSourcesFieldNumber;
#endif  // !_MSC_VER

TMCluster::TMCluster()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMCluster::InitAsDefaultInstance() {
}

TMCluster::TMCluster(const TMCluster& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMCluster::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMCluster::~TMCluster() {
  SharedDtor();
}

void TMCluster::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TMCluster::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMCluster::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMCluster_descriptor_;
}

const TMCluster& TMCluster::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMCluster* TMCluster::default_instance_ = NULL;

TMCluster* TMCluster::New() const {
  return new TMCluster;
}

void TMCluster::Clear() {
  clusternodes_.Clear();
  loadsources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMCluster::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clusterNodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_clusternodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_clusterNodes;
        if (input->ExpectTag(18)) goto parse_loadSources;
        break;
      }

      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loadSources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loadsources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_loadSources;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMCluster::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (int i = 0; i < this->clusternodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->clusternodes(i), output);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (int i = 0; i < this->loadsources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->loadsources(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMCluster::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (int i = 0; i < this->clusternodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->clusternodes(i), target);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (int i = 0; i < this->loadsources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->loadsources(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMCluster::ByteSize() const {
  int total_size = 0;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  total_size += 1 * this->clusternodes_size();
  for (int i = 0; i < this->clusternodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->clusternodes(i));
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  total_size += 1 * this->loadsources_size();
  for (int i = 0; i < this->loadsources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loadsources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMCluster::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMCluster* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMCluster*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMCluster::MergeFrom(const TMCluster& from) {
  GOOGLE_CHECK_NE(&from, this);
  clusternodes_.MergeFrom(from.clusternodes_);
  loadsources_.MergeFrom(from.loadsources_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMCluster::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMCluster::CopyFrom(const TMCluster& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMCluster::IsInitialized() const {

  for (int i = 0; i < clusternodes_size(); i++) {
    if (!this->clusternodes(i).IsInitialized()) return false;
  }
  for (int i = 0; i < loadsources_size(); i++) {
    if (!this->loadsources(i).IsInitialized()) return false;
  }
  return true;
}

void TMCluster::Swap(TMCluster* other) {
  if (other != this) {
    clusternodes_.Swap(&other->clusternodes_);
    loadsources_.Swap(&other->loadsources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMCluster::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMCluster_descriptor_;
  metadata.reflection = TMCluster_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMTransaction::kRawTransactionFieldNumber;
const int TMTransaction::kStatusFieldNumber;
const int TMTransaction::kReceiveTimestampFieldNumber;
const int TMTransaction::kDeferredFieldNumber;
#endif  // !_MSC_VER

TMTransaction::TMTransaction()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMTransaction::InitAsDefaultInstance() {
}

TMTransaction::TMTransaction(const TMTransaction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMTransaction::SharedCtor() {
  _cached_size_ = 0;
  rawtransaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 1;
  receivetimestamp_ = GOOGLE_ULONGLONG(0);
  deferred_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMTransaction::~TMTransaction() {
  SharedDtor();
}

void TMTransaction::SharedDtor() {
  if (rawtransaction_ != &::google::protobuf::internal::kEmptyString) {
    delete rawtransaction_;
  }
  if (this != default_instance_) {
  }
}

void TMTransaction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMTransaction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMTransaction_descriptor_;
}

const TMTransaction& TMTransaction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMTransaction* TMTransaction::default_instance_ = NULL;

TMTransaction* TMTransaction::New() const {
  return new TMTransaction;
}

void TMTransaction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_rawtransaction()) {
      if (rawtransaction_ != &::google::protobuf::internal::kEmptyString) {
        rawtransaction_->clear();
      }
    }
    status_ = 1;
    receivetimestamp_ = GOOGLE_ULONGLONG(0);
    deferred_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMTransaction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes rawTransaction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rawtransaction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .protocol.TransactionStatus status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TransactionStatus_IsValid(value)) {
            set_status(static_cast< ::protocol::TransactionStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_receiveTimestamp;
        break;
      }

      // optional uint64 receiveTimestamp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_receiveTimestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &receivetimestamp_)));
          set_has_receivetimestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_deferred;
        break;
      }

      // optional bool deferred = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deferred:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &deferred_)));
          set_has_deferred();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMTransaction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes rawTransaction = 1;
  if (has_rawtransaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->rawtransaction(), output);
  }

  // required .protocol.TransactionStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional uint64 receiveTimestamp = 3;
  if (has_receivetimestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->receivetimestamp(), output);
  }

  // optional bool deferred = 4;
  if (has_deferred()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->deferred(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMTransaction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes rawTransaction = 1;
  if (has_rawtransaction()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->rawtransaction(), target);
  }

  // required .protocol.TransactionStatus status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional uint64 receiveTimestamp = 3;
  if (has_receivetimestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->receivetimestamp(), target);
  }

  // optional bool deferred = 4;
  if (has_deferred()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->deferred(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMTransaction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes rawTransaction = 1;
    if (has_rawtransaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->rawtransaction());
    }

    // required .protocol.TransactionStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional uint64 receiveTimestamp = 3;
    if (has_receivetimestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->receivetimestamp());
    }

    // optional bool deferred = 4;
    if (has_deferred()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMTransaction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMTransaction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMTransaction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMTransaction::MergeFrom(const TMTransaction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rawtransaction()) {
      set_rawtransaction(from.rawtransaction());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_receivetimestamp()) {
      set_receivetimestamp(from.receivetimestamp());
    }
    if (from.has_deferred()) {
      set_deferred(from.deferred());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMTransaction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMTransaction::CopyFrom(const TMTransaction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransaction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TMTransaction::Swap(TMTransaction* other) {
  if (other != this) {
    std::swap(rawtransaction_, other->rawtransaction_);
    std::swap(status_, other->status_);
    std::swap(receivetimestamp_, other->receivetimestamp_);
    std::swap(deferred_, other->deferred_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMTransaction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMTransaction_descriptor_;
  metadata.reflection = TMTransaction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMStatusChange::kNewStatusFieldNumber;
const int TMStatusChange::kNewEventFieldNumber;
const int TMStatusChange::kLedgerSeqFieldNumber;
const int TMStatusChange::kLedgerHashFieldNumber;
const int TMStatusChange::kLedgerHashPreviousFieldNumber;
const int TMStatusChange::kNetworkTimeFieldNumber;
const int TMStatusChange::kFirstSeqFieldNumber;
const int TMStatusChange::kLastSeqFieldNumber;
#endif  // !_MSC_VER

TMStatusChange::TMStatusChange()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMStatusChange::InitAsDefaultInstance() {
}

TMStatusChange::TMStatusChange(const TMStatusChange& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMStatusChange::SharedCtor() {
  _cached_size_ = 0;
  newstatus_ = 1;
  newevent_ = 1;
  ledgerseq_ = 0u;
  ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ledgerhashprevious_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  networktime_ = GOOGLE_ULONGLONG(0);
  firstseq_ = 0u;
  lastseq_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMStatusChange::~TMStatusChange() {
  SharedDtor();
}

void TMStatusChange::SharedDtor() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (ledgerhashprevious_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhashprevious_;
  }
  if (this != default_instance_) {
  }
}

void TMStatusChange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMStatusChange::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMStatusChange_descriptor_;
}

const TMStatusChange& TMStatusChange::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMStatusChange* TMStatusChange::default_instance_ = NULL;

TMStatusChange* TMStatusChange::New() const {
  return new TMStatusChange;
}

void TMStatusChange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    newstatus_ = 1;
    newevent_ = 1;
    ledgerseq_ = 0u;
    if (has_ledgerhash()) {
      if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
        ledgerhash_->clear();
      }
    }
    if (has_ledgerhashprevious()) {
      if (ledgerhashprevious_ != &::google::protobuf::internal::kEmptyString) {
        ledgerhashprevious_->clear();
      }
    }
    networktime_ = GOOGLE_ULONGLONG(0);
    firstseq_ = 0u;
    lastseq_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMStatusChange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::NodeStatus_IsValid(value)) {
            set_newstatus(static_cast< ::protocol::NodeStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_newEvent;
        break;
      }

      // optional .protocol.NodeEvent newEvent = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_newEvent:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::NodeEvent_IsValid(value)) {
            set_newevent(static_cast< ::protocol::NodeEvent >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ledgerSeq;
        break;
      }

      // optional uint32 ledgerSeq = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ledgerSeq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
          set_has_ledgerseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ledgerHash;
        break;
      }

      // optional bytes ledgerHash = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ledgerHash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ledgerHashPrevious;
        break;
      }

      // optional bytes ledgerHashPrevious = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ledgerHashPrevious:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhashprevious()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_networkTime;
        break;
      }

      // optional uint64 networkTime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_networkTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &networktime_)));
          set_has_networktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_firstSeq;
        break;
      }

      // optional uint32 firstSeq = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_firstSeq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &firstseq_)));
          set_has_firstseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_lastSeq;
        break;
      }

      // optional uint32 lastSeq = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastSeq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastseq_)));
          set_has_lastseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMStatusChange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .protocol.NodeStatus newStatus = 1;
  if (has_newstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->newstatus(), output);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (has_newevent()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->newevent(), output);
  }

  // optional uint32 ledgerSeq = 3;
  if (has_ledgerseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ledgerseq(), output);
  }

  // optional bytes ledgerHash = 4;
  if (has_ledgerhash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->ledgerhash(), output);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (has_ledgerhashprevious()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->ledgerhashprevious(), output);
  }

  // optional uint64 networkTime = 6;
  if (has_networktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->networktime(), output);
  }

  // optional uint32 firstSeq = 7;
  if (has_firstseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->firstseq(), output);
  }

  // optional uint32 lastSeq = 8;
  if (has_lastseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->lastseq(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMStatusChange::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .protocol.NodeStatus newStatus = 1;
  if (has_newstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->newstatus(), target);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (has_newevent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->newevent(), target);
  }

  // optional uint32 ledgerSeq = 3;
  if (has_ledgerseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->ledgerseq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (has_ledgerhash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerhash(), target);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (has_ledgerhashprevious()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->ledgerhashprevious(), target);
  }

  // optional uint64 networkTime = 6;
  if (has_networktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->networktime(), target);
  }

  // optional uint32 firstSeq = 7;
  if (has_firstseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->firstseq(), target);
  }

  // optional uint32 lastSeq = 8;
  if (has_lastseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->lastseq(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMStatusChange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protocol.NodeStatus newStatus = 1;
    if (has_newstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->newstatus());
    }

    // optional .protocol.NodeEvent newEvent = 2;
    if (has_newevent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->newevent());
    }

    // optional uint32 ledgerSeq = 3;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // optional bytes ledgerHash = 4;
    if (has_ledgerhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhash());
    }

    // optional bytes ledgerHashPrevious = 5;
    if (has_ledgerhashprevious()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhashprevious());
    }

    // optional uint64 networkTime = 6;
    if (has_networktime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->networktime());
    }

    // optional uint32 firstSeq = 7;
    if (has_firstseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->firstseq());
    }

    // optional uint32 lastSeq = 8;
    if (has_lastseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lastseq());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMStatusChange::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMStatusChange* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMStatusChange*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMStatusChange::MergeFrom(const TMStatusChange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_newstatus()) {
      set_newstatus(from.newstatus());
    }
    if (from.has_newevent()) {
      set_newevent(from.newevent());
    }
    if (from.has_ledgerseq()) {
      set_ledgerseq(from.ledgerseq());
    }
    if (from.has_ledgerhash()) {
      set_ledgerhash(from.ledgerhash());
    }
    if (from.has_ledgerhashprevious()) {
      set_ledgerhashprevious(from.ledgerhashprevious());
    }
    if (from.has_networktime()) {
      set_networktime(from.networktime());
    }
    if (from.has_firstseq()) {
      set_firstseq(from.firstseq());
    }
    if (from.has_lastseq()) {
      set_lastseq(from.lastseq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMStatusChange::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMStatusChange::CopyFrom(const TMStatusChange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMStatusChange::IsInitialized() const {

  return true;
}

void TMStatusChange::Swap(TMStatusChange* other) {
  if (other != this) {
    std::swap(newstatus_, other->newstatus_);
    std::swap(newevent_, other->newevent_);
    std::swap(ledgerseq_, other->ledgerseq_);
    std::swap(ledgerhash_, other->ledgerhash_);
    std::swap(ledgerhashprevious_, other->ledgerhashprevious_);
    std::swap(networktime_, other->networktime_);
    std::swap(firstseq_, other->firstseq_);
    std::swap(lastseq_, other->lastseq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMStatusChange::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMStatusChange_descriptor_;
  metadata.reflection = TMStatusChange_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMProposeSet::kProposeSeqFieldNumber;
const int TMProposeSet::kCurrentTxHashFieldNumber;
const int TMProposeSet::kNodePubKeyFieldNumber;
const int TMProposeSet::kCloseTimeFieldNumber;
const int TMProposeSet::kSignatureFieldNumber;
const int TMProposeSet::kPreviousledgerFieldNumber;
const int TMProposeSet::kCheckedSignatureFieldNumber;
const int TMProposeSet::kAddedTransactionsFieldNumber;
const int TMProposeSet::kRemovedTransactionsFieldNumber;
const int TMProposeSet::kHopsFieldNumber;
#endif  // !_MSC_VER

TMProposeSet::TMProposeSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMProposeSet::InitAsDefaultInstance() {
}

TMProposeSet::TMProposeSet(const TMProposeSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMProposeSet::SharedCtor() {
  _cached_size_ = 0;
  proposeseq_ = 0u;
  currenttxhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nodepubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  closetime_ = 0u;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  previousledger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checkedsignature_ = false;
  hops_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMProposeSet::~TMProposeSet() {
  SharedDtor();
}

void TMProposeSet::SharedDtor() {
  if (currenttxhash_ != &::google::protobuf::internal::kEmptyString) {
    delete currenttxhash_;
  }
  if (nodepubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete nodepubkey_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (previousledger_ != &::google::protobuf::internal::kEmptyString) {
    delete previousledger_;
  }
  if (this != default_instance_) {
  }
}

void TMProposeSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMProposeSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMProposeSet_descriptor_;
}

const TMProposeSet& TMProposeSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMProposeSet* TMProposeSet::default_instance_ = NULL;

TMProposeSet* TMProposeSet::New() const {
  return new TMProposeSet;
}

void TMProposeSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    proposeseq_ = 0u;
    if (has_currenttxhash()) {
      if (currenttxhash_ != &::google::protobuf::internal::kEmptyString) {
        currenttxhash_->clear();
      }
    }
    if (has_nodepubkey()) {
      if (nodepubkey_ != &::google::protobuf::internal::kEmptyString) {
        nodepubkey_->clear();
      }
    }
    closetime_ = 0u;
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_previousledger()) {
      if (previousledger_ != &::google::protobuf::internal::kEmptyString) {
        previousledger_->clear();
      }
    }
    checkedsignature_ = false;
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    hops_ = 0u;
  }
  addedtransactions_.Clear();
  removedtransactions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMProposeSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 proposeSeq = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &proposeseq_)));
          set_has_proposeseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_currentTxHash;
        break;
      }

      // required bytes currentTxHash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_currentTxHash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_currenttxhash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_nodePubKey;
        break;
      }

      // required bytes nodePubKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodePubKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_closeTime;
        break;
      }

      // required uint32 closeTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_closeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &closetime_)));
          set_has_closetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_signature;
        break;
      }

      // required bytes signature = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_previousledger;
        break;
      }

      // optional bytes previousledger = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_previousledger:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_previousledger()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_checkedSignature;
        break;
      }

      // optional bool checkedSignature = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checkedSignature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkedsignature_)));
          set_has_checkedsignature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_addedTransactions;
        break;
      }

      // repeated bytes addedTransactions = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_addedTransactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_addedtransactions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_addedTransactions;
        if (input->ExpectTag(90)) goto parse_removedTransactions;
        break;
      }

      // repeated bytes removedTransactions = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_removedTransactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_removedtransactions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_removedTransactions;
        if (input->ExpectTag(96)) goto parse_hops;
        break;
      }

      // optional uint32 hops = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
          set_has_hops();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMProposeSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 proposeSeq = 1;
  if (has_proposeseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->proposeseq(), output);
  }

  // required bytes currentTxHash = 2;
  if (has_currenttxhash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->currenttxhash(), output);
  }

  // required bytes nodePubKey = 3;
  if (has_nodepubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->nodepubkey(), output);
  }

  // required uint32 closeTime = 4;
  if (has_closetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->closetime(), output);
  }

  // required bytes signature = 5;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->signature(), output);
  }

  // optional bytes previousledger = 6;
  if (has_previousledger()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->previousledger(), output);
  }

  // optional bool checkedSignature = 7;
  if (has_checkedsignature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->checkedsignature(), output);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0; i < this->addedtransactions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->addedtransactions(i), output);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0; i < this->removedtransactions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->removedtransactions(i), output);
  }

  // optional uint32 hops = 12;
  if (has_hops()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->hops(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMProposeSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 proposeSeq = 1;
  if (has_proposeseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->proposeseq(), target);
  }

  // required bytes currentTxHash = 2;
  if (has_currenttxhash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->currenttxhash(), target);
  }

  // required bytes nodePubKey = 3;
  if (has_nodepubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nodepubkey(), target);
  }

  // required uint32 closeTime = 4;
  if (has_closetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->closetime(), target);
  }

  // required bytes signature = 5;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->signature(), target);
  }

  // optional bytes previousledger = 6;
  if (has_previousledger()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->previousledger(), target);
  }

  // optional bool checkedSignature = 7;
  if (has_checkedsignature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->checkedsignature(), target);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0; i < this->addedtransactions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(10, this->addedtransactions(i), target);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0; i < this->removedtransactions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(11, this->removedtransactions(i), target);
  }

  // optional uint32 hops = 12;
  if (has_hops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->hops(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMProposeSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 proposeSeq = 1;
    if (has_proposeseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->proposeseq());
    }

    // required bytes currentTxHash = 2;
    if (has_currenttxhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->currenttxhash());
    }

    // required bytes nodePubKey = 3;
    if (has_nodepubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodepubkey());
    }

    // required uint32 closeTime = 4;
    if (has_closetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->closetime());
    }

    // required bytes signature = 5;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes previousledger = 6;
    if (has_previousledger()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->previousledger());
    }

    // optional bool checkedSignature = 7;
    if (has_checkedsignature()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional uint32 hops = 12;
    if (has_hops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  // repeated bytes addedTransactions = 10;
  total_size += 1 * this->addedtransactions_size();
  for (int i = 0; i < this->addedtransactions_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->addedtransactions(i));
  }

  // repeated bytes removedTransactions = 11;
  total_size += 1 * this->removedtransactions_size();
  for (int i = 0; i < this->removedtransactions_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->removedtransactions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMProposeSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMProposeSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMProposeSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMProposeSet::MergeFrom(const TMProposeSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  addedtransactions_.MergeFrom(from.addedtransactions_);
  removedtransactions_.MergeFrom(from.removedtransactions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_proposeseq()) {
      set_proposeseq(from.proposeseq());
    }
    if (from.has_currenttxhash()) {
      set_currenttxhash(from.currenttxhash());
    }
    if (from.has_nodepubkey()) {
      set_nodepubkey(from.nodepubkey());
    }
    if (from.has_closetime()) {
      set_closetime(from.closetime());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_previousledger()) {
      set_previousledger(from.previousledger());
    }
    if (from.has_checkedsignature()) {
      set_checkedsignature(from.checkedsignature());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_hops()) {
      set_hops(from.hops());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMProposeSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProposeSet::CopyFrom(const TMProposeSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProposeSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void TMProposeSet::Swap(TMProposeSet* other) {
  if (other != this) {
    std::swap(proposeseq_, other->proposeseq_);
    std::swap(currenttxhash_, other->currenttxhash_);
    std::swap(nodepubkey_, other->nodepubkey_);
    std::swap(closetime_, other->closetime_);
    std::swap(signature_, other->signature_);
    std::swap(previousledger_, other->previousledger_);
    std::swap(checkedsignature_, other->checkedsignature_);
    addedtransactions_.Swap(&other->addedtransactions_);
    removedtransactions_.Swap(&other->removedtransactions_);
    std::swap(hops_, other->hops_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMProposeSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMProposeSet_descriptor_;
  metadata.reflection = TMProposeSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMHaveTransactionSet::kStatusFieldNumber;
const int TMHaveTransactionSet::kHashFieldNumber;
#endif  // !_MSC_VER

TMHaveTransactionSet::TMHaveTransactionSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMHaveTransactionSet::InitAsDefaultInstance() {
}

TMHaveTransactionSet::TMHaveTransactionSet(const TMHaveTransactionSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMHaveTransactionSet::SharedCtor() {
  _cached_size_ = 0;
  status_ = 1;
  hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMHaveTransactionSet::~TMHaveTransactionSet() {
  SharedDtor();
}

void TMHaveTransactionSet::SharedDtor() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (this != default_instance_) {
  }
}

void TMHaveTransactionSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMHaveTransactionSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMHaveTransactionSet_descriptor_;
}

const TMHaveTransactionSet& TMHaveTransactionSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMHaveTransactionSet* TMHaveTransactionSet::default_instance_ = NULL;

TMHaveTransactionSet* TMHaveTransactionSet::New() const {
  return new TMHaveTransactionSet;
}

void TMHaveTransactionSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 1;
    if (has_hash()) {
      if (hash_ != &::google::protobuf::internal::kEmptyString) {
        hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMHaveTransactionSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TxSetStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TxSetStatus_IsValid(value)) {
            set_status(static_cast< ::protocol::TxSetStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hash;
        break;
      }

      // required bytes hash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMHaveTransactionSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .protocol.TxSetStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // required bytes hash = 2;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMHaveTransactionSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .protocol.TxSetStatus status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->status(), target);
  }

  // required bytes hash = 2;
  if (has_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMHaveTransactionSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .protocol.TxSetStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required bytes hash = 2;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMHaveTransactionSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMHaveTransactionSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMHaveTransactionSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMHaveTransactionSet::MergeFrom(const TMHaveTransactionSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_hash()) {
      set_hash(from.hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMHaveTransactionSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHaveTransactionSet::CopyFrom(const TMHaveTransactionSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactionSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TMHaveTransactionSet::Swap(TMHaveTransactionSet* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(hash_, other->hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMHaveTransactionSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMHaveTransactionSet_descriptor_;
  metadata.reflection = TMHaveTransactionSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMValidation::kValidationFieldNumber;
const int TMValidation::kCheckedSignatureFieldNumber;
const int TMValidation::kHopsFieldNumber;
#endif  // !_MSC_VER

TMValidation::TMValidation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMValidation::InitAsDefaultInstance() {
}

TMValidation::TMValidation(const TMValidation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMValidation::SharedCtor() {
  _cached_size_ = 0;
  validation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checkedsignature_ = false;
  hops_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMValidation::~TMValidation() {
  SharedDtor();
}

void TMValidation::SharedDtor() {
  if (validation_ != &::google::protobuf::internal::kEmptyString) {
    delete validation_;
  }
  if (this != default_instance_) {
  }
}

void TMValidation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMValidation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMValidation_descriptor_;
}

const TMValidation& TMValidation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMValidation* TMValidation::default_instance_ = NULL;

TMValidation* TMValidation::New() const {
  return new TMValidation;
}

void TMValidation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_validation()) {
      if (validation_ != &::google::protobuf::internal::kEmptyString) {
        validation_->clear();
      }
    }
    checkedsignature_ = false;
    hops_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMValidation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes validation = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_validation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checkedSignature;
        break;
      }

      // optional bool checkedSignature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checkedSignature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkedsignature_)));
          set_has_checkedsignature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_hops;
        break;
      }

      // optional uint32 hops = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
          set_has_hops();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMValidation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes validation = 1;
  if (has_validation()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->validation(), output);
  }

  // optional bool checkedSignature = 2;
  if (has_checkedsignature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->checkedsignature(), output);
  }

  // optional uint32 hops = 3;
  if (has_hops()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->hops(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMValidation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes validation = 1;
  if (has_validation()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->validation(), target);
  }

  // optional bool checkedSignature = 2;
  if (has_checkedsignature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->checkedsignature(), target);
  }

  // optional uint32 hops = 3;
  if (has_hops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->hops(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMValidation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes validation = 1;
    if (has_validation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->validation());
    }

    // optional bool checkedSignature = 2;
    if (has_checkedsignature()) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 3;
    if (has_hops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMValidation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMValidation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMValidation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMValidation::MergeFrom(const TMValidation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_validation()) {
      set_validation(from.validation());
    }
    if (from.has_checkedsignature()) {
      set_checkedsignature(from.checkedsignature());
    }
    if (from.has_hops()) {
      set_hops(from.hops());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMValidation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidation::CopyFrom(const TMValidation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TMValidation::Swap(TMValidation* other) {
  if (other != this) {
    std::swap(validation_, other->validation_);
    std::swap(checkedsignature_, other->checkedsignature_);
    std::swap(hops_, other->hops_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMValidation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMValidation_descriptor_;
  metadata.reflection = TMValidation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMGetPeers::kDoWeNeedThisFieldNumber;
#endif  // !_MSC_VER

TMGetPeers::TMGetPeers()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMGetPeers::InitAsDefaultInstance() {
}

TMGetPeers::TMGetPeers(const TMGetPeers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMGetPeers::SharedCtor() {
  _cached_size_ = 0;
  doweneedthis_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMGetPeers::~TMGetPeers() {
  SharedDtor();
}

void TMGetPeers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TMGetPeers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMGetPeers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMGetPeers_descriptor_;
}

const TMGetPeers& TMGetPeers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMGetPeers* TMGetPeers::default_instance_ = NULL;

TMGetPeers* TMGetPeers::New() const {
  return new TMGetPeers;
}

void TMGetPeers::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    doweneedthis_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMGetPeers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 doWeNeedThis = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &doweneedthis_)));
          set_has_doweneedthis();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMGetPeers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 doWeNeedThis = 1;
  if (has_doweneedthis()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->doweneedthis(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMGetPeers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 doWeNeedThis = 1;
  if (has_doweneedthis()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->doweneedthis(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMGetPeers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 doWeNeedThis = 1;
    if (has_doweneedthis()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->doweneedthis());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMGetPeers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMGetPeers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMGetPeers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMGetPeers::MergeFrom(const TMGetPeers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_doweneedthis()) {
      set_doweneedthis(from.doweneedthis());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMGetPeers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetPeers::CopyFrom(const TMGetPeers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TMGetPeers::Swap(TMGetPeers* other) {
  if (other != this) {
    std::swap(doweneedthis_, other->doweneedthis_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMGetPeers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMGetPeers_descriptor_;
  metadata.reflection = TMGetPeers_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMIPv4Endpoint::kIpv4FieldNumber;
const int TMIPv4Endpoint::kIpv4PortFieldNumber;
#endif  // !_MSC_VER

TMIPv4Endpoint::TMIPv4Endpoint()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMIPv4Endpoint::InitAsDefaultInstance() {
}

TMIPv4Endpoint::TMIPv4Endpoint(const TMIPv4Endpoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMIPv4Endpoint::SharedCtor() {
  _cached_size_ = 0;
  ipv4_ = 0u;
  ipv4port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMIPv4Endpoint::~TMIPv4Endpoint() {
  SharedDtor();
}

void TMIPv4Endpoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TMIPv4Endpoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMIPv4Endpoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMIPv4Endpoint_descriptor_;
}

const TMIPv4Endpoint& TMIPv4Endpoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMIPv4Endpoint* TMIPv4Endpoint::default_instance_ = NULL;

TMIPv4Endpoint* TMIPv4Endpoint::New() const {
  return new TMIPv4Endpoint;
}

void TMIPv4Endpoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ipv4_ = 0u;
    ipv4port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMIPv4Endpoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ipv4 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipv4_)));
          set_has_ipv4();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ipv4Port;
        break;
      }

      // required uint32 ipv4Port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ipv4Port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipv4port_)));
          set_has_ipv4port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMIPv4Endpoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ipv4 = 1;
  if (has_ipv4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ipv4(), output);
  }

  // required uint32 ipv4Port = 2;
  if (has_ipv4port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ipv4port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMIPv4Endpoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 ipv4 = 1;
  if (has_ipv4()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ipv4(), target);
  }

  // required uint32 ipv4Port = 2;
  if (has_ipv4port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ipv4port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMIPv4Endpoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ipv4 = 1;
    if (has_ipv4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ipv4());
    }

    // required uint32 ipv4Port = 2;
    if (has_ipv4port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ipv4port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMIPv4Endpoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMIPv4Endpoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMIPv4Endpoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMIPv4Endpoint::MergeFrom(const TMIPv4Endpoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ipv4()) {
      set_ipv4(from.ipv4());
    }
    if (from.has_ipv4port()) {
      set_ipv4port(from.ipv4port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMIPv4Endpoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIPv4Endpoint::CopyFrom(const TMIPv4Endpoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIPv4Endpoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TMIPv4Endpoint::Swap(TMIPv4Endpoint* other) {
  if (other != this) {
    std::swap(ipv4_, other->ipv4_);
    std::swap(ipv4port_, other->ipv4port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMIPv4Endpoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMIPv4Endpoint_descriptor_;
  metadata.reflection = TMIPv4Endpoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMPeers::kNodesFieldNumber;
#endif  // !_MSC_VER

TMPeers::TMPeers()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMPeers::InitAsDefaultInstance() {
}

TMPeers::TMPeers(const TMPeers& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMPeers::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMPeers::~TMPeers() {
  SharedDtor();
}

void TMPeers::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TMPeers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMPeers::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMPeers_descriptor_;
}

const TMPeers& TMPeers::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMPeers* TMPeers::default_instance_ = NULL;

TMPeers* TMPeers::New() const {
  return new TMPeers;
}

void TMPeers::Clear() {
  nodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMPeers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMIPv4Endpoint nodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_nodes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMPeers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nodes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMPeers::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nodes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMPeers::ByteSize() const {
  int total_size = 0;

  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMPeers::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMPeers* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMPeers*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMPeers::MergeFrom(const TMPeers& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMPeers::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeers::CopyFrom(const TMPeers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeers::IsInitialized() const {

  for (int i = 0; i < nodes_size(); i++) {
    if (!this->nodes(i).IsInitialized()) return false;
  }
  return true;
}

void TMPeers::Swap(TMPeers* other) {
  if (other != this) {
    nodes_.Swap(&other->nodes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMPeers::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMPeers_descriptor_;
  metadata.reflection = TMPeers_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMEndpoint::kIpv4FieldNumber;
const int TMEndpoint::kHopsFieldNumber;
#endif  // !_MSC_VER

TMEndpoint::TMEndpoint()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMEndpoint::InitAsDefaultInstance() {
  ipv4_ = const_cast< ::protocol::TMIPv4Endpoint*>(&::protocol::TMIPv4Endpoint::default_instance());
}

TMEndpoint::TMEndpoint(const TMEndpoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMEndpoint::SharedCtor() {
  _cached_size_ = 0;
  ipv4_ = NULL;
  hops_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMEndpoint::~TMEndpoint() {
  SharedDtor();
}

void TMEndpoint::SharedDtor() {
  if (this != default_instance_) {
    delete ipv4_;
  }
}

void TMEndpoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMEndpoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMEndpoint_descriptor_;
}

const TMEndpoint& TMEndpoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMEndpoint* TMEndpoint::default_instance_ = NULL;

TMEndpoint* TMEndpoint::New() const {
  return new TMEndpoint;
}

void TMEndpoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ipv4()) {
      if (ipv4_ != NULL) ipv4_->::protocol::TMIPv4Endpoint::Clear();
    }
    hops_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMEndpoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMIPv4Endpoint ipv4 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ipv4()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_hops;
        break;
      }

      // required uint32 hops = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
          set_has_hops();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMEndpoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .protocol.TMIPv4Endpoint ipv4 = 1;
  if (has_ipv4()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ipv4(), output);
  }

  // required uint32 hops = 2;
  if (has_hops()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->hops(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMEndpoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .protocol.TMIPv4Endpoint ipv4 = 1;
  if (has_ipv4()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ipv4(), target);
  }

  // required uint32 hops = 2;
  if (has_hops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->hops(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMEndpoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .protocol.TMIPv4Endpoint ipv4 = 1;
    if (has_ipv4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ipv4());
    }

    // required uint32 hops = 2;
    if (has_hops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMEndpoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMEndpoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMEndpoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMEndpoint::MergeFrom(const TMEndpoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ipv4()) {
      mutable_ipv4()->::protocol::TMIPv4Endpoint::MergeFrom(from.ipv4());
    }
    if (from.has_hops()) {
      set_hops(from.hops());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMEndpoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoint::CopyFrom(const TMEndpoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_ipv4()) {
    if (!this->ipv4().IsInitialized()) return false;
  }
  return true;
}

void TMEndpoint::Swap(TMEndpoint* other) {
  if (other != this) {
    std::swap(ipv4_, other->ipv4_);
    std::swap(hops_, other->hops_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMEndpoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMEndpoint_descriptor_;
  metadata.reflection = TMEndpoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMEndpoints::kVersionFieldNumber;
const int TMEndpoints::kEndpointsFieldNumber;
#endif  // !_MSC_VER

TMEndpoints::TMEndpoints()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMEndpoints::InitAsDefaultInstance() {
}

TMEndpoints::TMEndpoints(const TMEndpoints& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMEndpoints::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMEndpoints::~TMEndpoints() {
  SharedDtor();
}

void TMEndpoints::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TMEndpoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMEndpoints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMEndpoints_descriptor_;
}

const TMEndpoints& TMEndpoints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMEndpoints* TMEndpoints::default_instance_ = NULL;

TMEndpoints* TMEndpoints::New() const {
  return new TMEndpoints;
}

void TMEndpoints::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
  }
  endpoints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMEndpoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_endpoints;
        break;
      }

      // repeated .protocol.TMEndpoint endpoints = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_endpoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_endpoints()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_endpoints;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMEndpoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // repeated .protocol.TMEndpoint endpoints = 2;
  for (int i = 0; i < this->endpoints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->endpoints(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMEndpoints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // repeated .protocol.TMEndpoint endpoints = 2;
  for (int i = 0; i < this->endpoints_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->endpoints(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMEndpoints::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

  }
  // repeated .protocol.TMEndpoint endpoints = 2;
  total_size += 1 * this->endpoints_size();
  for (int i = 0; i < this->endpoints_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->endpoints(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMEndpoints::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMEndpoints* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMEndpoints*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMEndpoints::MergeFrom(const TMEndpoints& from) {
  GOOGLE_CHECK_NE(&from, this);
  endpoints_.MergeFrom(from.endpoints_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMEndpoints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints::CopyFrom(const TMEndpoints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < endpoints_size(); i++) {
    if (!this->endpoints(i).IsInitialized()) return false;
  }
  return true;
}

void TMEndpoints::Swap(TMEndpoints* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    endpoints_.Swap(&other->endpoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMEndpoints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMEndpoints_descriptor_;
  metadata.reflection = TMEndpoints_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMIndexedObject::kHashFieldNumber;
const int TMIndexedObject::kNodeIDFieldNumber;
const int TMIndexedObject::kIndexFieldNumber;
const int TMIndexedObject::kDataFieldNumber;
const int TMIndexedObject::kLedgerSeqFieldNumber;
#endif  // !_MSC_VER

TMIndexedObject::TMIndexedObject()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMIndexedObject::InitAsDefaultInstance() {
}

TMIndexedObject::TMIndexedObject(const TMIndexedObject& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMIndexedObject::SharedCtor() {
  _cached_size_ = 0;
  hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ledgerseq_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMIndexedObject::~TMIndexedObject() {
  SharedDtor();
}

void TMIndexedObject::SharedDtor() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    delete nodeid_;
  }
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    delete index_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void TMIndexedObject::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMIndexedObject::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMIndexedObject_descriptor_;
}

const TMIndexedObject& TMIndexedObject::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMIndexedObject* TMIndexedObject::default_instance_ = NULL;

TMIndexedObject* TMIndexedObject::New() const {
  return new TMIndexedObject;
}

void TMIndexedObject::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_hash()) {
      if (hash_ != &::google::protobuf::internal::kEmptyString) {
        hash_->clear();
      }
    }
    if (has_nodeid()) {
      if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
        nodeid_->clear();
      }
    }
    if (has_index()) {
      if (index_ != &::google::protobuf::internal::kEmptyString) {
        index_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    ledgerseq_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMIndexedObject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_nodeID;
        break;
      }

      // optional bytes nodeID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodeID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_index;
        break;
      }

      // optional bytes index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_index:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_index()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ledgerSeq;
        break;
      }

      // optional uint32 ledgerSeq = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ledgerSeq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
          set_has_ledgerseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMIndexedObject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes hash = 1;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->hash(), output);
  }

  // optional bytes nodeID = 2;
  if (has_nodeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->nodeid(), output);
  }

  // optional bytes index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->index(), output);
  }

  // optional bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->data(), output);
  }

  // optional uint32 ledgerSeq = 5;
  if (has_ledgerseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ledgerseq(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMIndexedObject::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes hash = 1;
  if (has_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->hash(), target);
  }

  // optional bytes nodeID = 2;
  if (has_nodeid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodeid(), target);
  }

  // optional bytes index = 3;
  if (has_index()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->index(), target);
  }

  // optional bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  // optional uint32 ledgerSeq = 5;
  if (has_ledgerseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->ledgerseq(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMIndexedObject::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes hash = 1;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional bytes nodeID = 2;
    if (has_nodeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodeid());
    }

    // optional bytes index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->index());
    }

    // optional bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional uint32 ledgerSeq = 5;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMIndexedObject::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMIndexedObject* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMIndexedObject*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMIndexedObject::MergeFrom(const TMIndexedObject& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hash()) {
      set_hash(from.hash());
    }
    if (from.has_nodeid()) {
      set_nodeid(from.nodeid());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_ledgerseq()) {
      set_ledgerseq(from.ledgerseq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMIndexedObject::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIndexedObject::CopyFrom(const TMIndexedObject& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIndexedObject::IsInitialized() const {

  return true;
}

void TMIndexedObject::Swap(TMIndexedObject* other) {
  if (other != this) {
    std::swap(hash_, other->hash_);
    std::swap(nodeid_, other->nodeid_);
    std::swap(index_, other->index_);
    std::swap(data_, other->data_);
    std::swap(ledgerseq_, other->ledgerseq_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMIndexedObject::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMIndexedObject_descriptor_;
  metadata.reflection = TMIndexedObject_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMGetObjectByHash_ObjectType_descriptor_;
}
bool TMGetObjectByHash_ObjectType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otUNKNOWN;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otLEDGER;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION_NODE;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otSTATE_NODE;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otCAS_OBJECT;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otFETCH_PACK;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MIN;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MAX;
const int TMGetObjectByHash::ObjectType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TMGetObjectByHash::kTypeFieldNumber;
const int TMGetObjectByHash::kQueryFieldNumber;
const int TMGetObjectByHash::kSeqFieldNumber;
const int TMGetObjectByHash::kLedgerHashFieldNumber;
const int TMGetObjectByHash::kFatFieldNumber;
const int TMGetObjectByHash::kObjectsFieldNumber;
#endif  // !_MSC_VER

TMGetObjectByHash::TMGetObjectByHash()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMGetObjectByHash::InitAsDefaultInstance() {
}

TMGetObjectByHash::TMGetObjectByHash(const TMGetObjectByHash& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMGetObjectByHash::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  query_ = false;
  seq_ = 0u;
  ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fat_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMGetObjectByHash::~TMGetObjectByHash() {
  SharedDtor();
}

void TMGetObjectByHash::SharedDtor() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (this != default_instance_) {
  }
}

void TMGetObjectByHash::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMGetObjectByHash::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMGetObjectByHash_descriptor_;
}

const TMGetObjectByHash& TMGetObjectByHash::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMGetObjectByHash* TMGetObjectByHash::default_instance_ = NULL;

TMGetObjectByHash* TMGetObjectByHash::New() const {
  return new TMGetObjectByHash;
}

void TMGetObjectByHash::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    query_ = false;
    seq_ = 0u;
    if (has_ledgerhash()) {
      if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
        ledgerhash_->clear();
      }
    }
    fat_ = false;
  }
  objects_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMGetObjectByHash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMGetObjectByHash_ObjectType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMGetObjectByHash_ObjectType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_query;
        break;
      }

      // required bool query = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_query:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &query_)));
          set_has_query();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_seq;
        break;
      }

      // optional uint32 seq = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ledgerHash;
        break;
      }

      // optional bytes ledgerHash = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ledgerHash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fat;
        break;
      }

      // optional bool fat = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fat_)));
          set_has_fat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_objects;
        break;
      }

      // repeated .protocol.TMIndexedObject objects = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_objects:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_objects()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_objects;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMGetObjectByHash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required bool query = 2;
  if (has_query()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->query(), output);
  }

  // optional uint32 seq = 3;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->seq(), output);
  }

  // optional bytes ledgerHash = 4;
  if (has_ledgerhash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->ledgerhash(), output);
  }

  // optional bool fat = 5;
  if (has_fat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->fat(), output);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (int i = 0; i < this->objects_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->objects(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMGetObjectByHash::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required bool query = 2;
  if (has_query()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->query(), target);
  }

  // optional uint32 seq = 3;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->seq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (has_ledgerhash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerhash(), target);
  }

  // optional bool fat = 5;
  if (has_fat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->fat(), target);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (int i = 0; i < this->objects_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->objects(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMGetObjectByHash::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required bool query = 2;
    if (has_query()) {
      total_size += 1 + 1;
    }

    // optional uint32 seq = 3;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seq());
    }

    // optional bytes ledgerHash = 4;
    if (has_ledgerhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhash());
    }

    // optional bool fat = 5;
    if (has_fat()) {
      total_size += 1 + 1;
    }

  }
  // repeated .protocol.TMIndexedObject objects = 6;
  total_size += 1 * this->objects_size();
  for (int i = 0; i < this->objects_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->objects(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMGetObjectByHash::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMGetObjectByHash* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMGetObjectByHash*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMGetObjectByHash::MergeFrom(const TMGetObjectByHash& from) {
  GOOGLE_CHECK_NE(&from, this);
  objects_.MergeFrom(from.objects_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_query()) {
      set_query(from.query());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_ledgerhash()) {
      set_ledgerhash(from.ledgerhash());
    }
    if (from.has_fat()) {
      set_fat(from.fat());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMGetObjectByHash::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetObjectByHash::CopyFrom(const TMGetObjectByHash& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetObjectByHash::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TMGetObjectByHash::Swap(TMGetObjectByHash* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(query_, other->query_);
    std::swap(seq_, other->seq_);
    std::swap(ledgerhash_, other->ledgerhash_);
    std::swap(fat_, other->fat_);
    objects_.Swap(&other->objects_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMGetObjectByHash::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMGetObjectByHash_descriptor_;
  metadata.reflection = TMGetObjectByHash_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMLedgerNode::kNodedataFieldNumber;
const int TMLedgerNode::kNodeidFieldNumber;
#endif  // !_MSC_VER

TMLedgerNode::TMLedgerNode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMLedgerNode::InitAsDefaultInstance() {
}

TMLedgerNode::TMLedgerNode(const TMLedgerNode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMLedgerNode::SharedCtor() {
  _cached_size_ = 0;
  nodedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMLedgerNode::~TMLedgerNode() {
  SharedDtor();
}

void TMLedgerNode::SharedDtor() {
  if (nodedata_ != &::google::protobuf::internal::kEmptyString) {
    delete nodedata_;
  }
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    delete nodeid_;
  }
  if (this != default_instance_) {
  }
}

void TMLedgerNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMLedgerNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMLedgerNode_descriptor_;
}

const TMLedgerNode& TMLedgerNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMLedgerNode* TMLedgerNode::default_instance_ = NULL;

TMLedgerNode* TMLedgerNode::New() const {
  return new TMLedgerNode;
}

void TMLedgerNode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_nodedata()) {
      if (nodedata_ != &::google::protobuf::internal::kEmptyString) {
        nodedata_->clear();
      }
    }
    if (has_nodeid()) {
      if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
        nodeid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMLedgerNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes nodedata = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_nodeid;
        break;
      }

      // optional bytes nodeid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodeid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMLedgerNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes nodedata = 1;
  if (has_nodedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->nodedata(), output);
  }

  // optional bytes nodeid = 2;
  if (has_nodeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->nodeid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMLedgerNode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes nodedata = 1;
  if (has_nodedata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->nodedata(), target);
  }

  // optional bytes nodeid = 2;
  if (has_nodeid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodeid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMLedgerNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes nodedata = 1;
    if (has_nodedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodedata());
    }

    // optional bytes nodeid = 2;
    if (has_nodeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodeid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMLedgerNode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMLedgerNode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMLedgerNode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMLedgerNode::MergeFrom(const TMLedgerNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nodedata()) {
      set_nodedata(from.nodedata());
    }
    if (from.has_nodeid()) {
      set_nodeid(from.nodeid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMLedgerNode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerNode::CopyFrom(const TMLedgerNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TMLedgerNode::Swap(TMLedgerNode* other) {
  if (other != this) {
    std::swap(nodedata_, other->nodedata_);
    std::swap(nodeid_, other->nodeid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMLedgerNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMLedgerNode_descriptor_;
  metadata.reflection = TMLedgerNode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMGetLedger::kItypeFieldNumber;
const int TMGetLedger::kLtypeFieldNumber;
const int TMGetLedger::kLedgerHashFieldNumber;
const int TMGetLedger::kLedgerSeqFieldNumber;
const int TMGetLedger::kNodeIDsFieldNumber;
const int TMGetLedger::kRequestCookieFieldNumber;
const int TMGetLedger::kQueryTypeFieldNumber;
const int TMGetLedger::kQueryDepthFieldNumber;
#endif  // !_MSC_VER

TMGetLedger::TMGetLedger()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMGetLedger::InitAsDefaultInstance() {
}

TMGetLedger::TMGetLedger(const TMGetLedger& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMGetLedger::SharedCtor() {
  _cached_size_ = 0;
  itype_ = 0;
  ltype_ = 0;
  ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ledgerseq_ = 0u;
  requestcookie_ = GOOGLE_ULONGLONG(0);
  querytype_ = 0;
  querydepth_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMGetLedger::~TMGetLedger() {
  SharedDtor();
}

void TMGetLedger::SharedDtor() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (this != default_instance_) {
  }
}

void TMGetLedger::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMGetLedger::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMGetLedger_descriptor_;
}

const TMGetLedger& TMGetLedger::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMGetLedger* TMGetLedger::default_instance_ = NULL;

TMGetLedger* TMGetLedger::New() const {
  return new TMGetLedger;
}

void TMGetLedger::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itype_ = 0;
    ltype_ = 0;
    if (has_ledgerhash()) {
      if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
        ledgerhash_->clear();
      }
    }
    ledgerseq_ = 0u;
    requestcookie_ = GOOGLE_ULONGLONG(0);
    querytype_ = 0;
    querydepth_ = 0u;
  }
  nodeids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMGetLedger::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerInfoType_IsValid(value)) {
            set_itype(static_cast< ::protocol::TMLedgerInfoType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ltype;
        break;
      }

      // optional .protocol.TMLedgerType ltype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ltype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerType_IsValid(value)) {
            set_ltype(static_cast< ::protocol::TMLedgerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ledgerHash;
        break;
      }

      // optional bytes ledgerHash = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ledgerHash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ledgerSeq;
        break;
      }

      // optional uint32 ledgerSeq = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ledgerSeq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
          set_has_ledgerseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_nodeIDs;
        break;
      }

      // repeated bytes nodeIDs = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodeIDs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_nodeids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_nodeIDs;
        if (input->ExpectTag(48)) goto parse_requestCookie;
        break;
      }

      // optional uint64 requestCookie = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_requestCookie:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requestcookie_)));
          set_has_requestcookie();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_queryType;
        break;
      }

      // optional .protocol.TMQueryType queryType = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_queryType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMQueryType_IsValid(value)) {
            set_querytype(static_cast< ::protocol::TMQueryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_queryDepth;
        break;
      }

      // optional uint32 queryDepth = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_queryDepth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &querydepth_)));
          set_has_querydepth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMGetLedger::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .protocol.TMLedgerInfoType itype = 1;
  if (has_itype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->itype(), output);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (has_ltype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->ltype(), output);
  }

  // optional bytes ledgerHash = 3;
  if (has_ledgerhash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->ledgerhash(), output);
  }

  // optional uint32 ledgerSeq = 4;
  if (has_ledgerseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->ledgerseq(), output);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0; i < this->nodeids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->nodeids(i), output);
  }

  // optional uint64 requestCookie = 6;
  if (has_requestcookie()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->requestcookie(), output);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (has_querytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->querytype(), output);
  }

  // optional uint32 queryDepth = 8;
  if (has_querydepth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->querydepth(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMGetLedger::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .protocol.TMLedgerInfoType itype = 1;
  if (has_itype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->itype(), target);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (has_ltype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->ltype(), target);
  }

  // optional bytes ledgerHash = 3;
  if (has_ledgerhash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ledgerhash(), target);
  }

  // optional uint32 ledgerSeq = 4;
  if (has_ledgerseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->ledgerseq(), target);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0; i < this->nodeids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(5, this->nodeids(i), target);
  }

  // optional uint64 requestCookie = 6;
  if (has_requestcookie()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->requestcookie(), target);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (has_querytype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->querytype(), target);
  }

  // optional uint32 queryDepth = 8;
  if (has_querydepth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->querydepth(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMGetLedger::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .protocol.TMLedgerInfoType itype = 1;
    if (has_itype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->itype());
    }

    // optional .protocol.TMLedgerType ltype = 2;
    if (has_ltype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ltype());
    }

    // optional bytes ledgerHash = 3;
    if (has_ledgerhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhash());
    }

    // optional uint32 ledgerSeq = 4;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // optional uint64 requestCookie = 6;
    if (has_requestcookie()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->requestcookie());
    }

    // optional .protocol.TMQueryType queryType = 7;
    if (has_querytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->querytype());
    }

    // optional uint32 queryDepth = 8;
    if (has_querydepth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->querydepth());
    }

  }
  // repeated bytes nodeIDs = 5;
  total_size += 1 * this->nodeids_size();
  for (int i = 0; i < this->nodeids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->nodeids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMGetLedger::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMGetLedger* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMGetLedger*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMGetLedger::MergeFrom(const TMGetLedger& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodeids_.MergeFrom(from.nodeids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itype()) {
      set_itype(from.itype());
    }
    if (from.has_ltype()) {
      set_ltype(from.ltype());
    }
    if (from.has_ledgerhash()) {
      set_ledgerhash(from.ledgerhash());
    }
    if (from.has_ledgerseq()) {
      set_ledgerseq(from.ledgerseq());
    }
    if (from.has_requestcookie()) {
      set_requestcookie(from.requestcookie());
    }
    if (from.has_querytype()) {
      set_querytype(from.querytype());
    }
    if (from.has_querydepth()) {
      set_querydepth(from.querydepth());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMGetLedger::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetLedger::CopyFrom(const TMGetLedger& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetLedger::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TMGetLedger::Swap(TMGetLedger* other) {
  if (other != this) {
    std::swap(itype_, other->itype_);
    std::swap(ltype_, other->ltype_);
    std::swap(ledgerhash_, other->ledgerhash_);
    std::swap(ledgerseq_, other->ledgerseq_);
    nodeids_.Swap(&other->nodeids_);
    std::swap(requestcookie_, other->requestcookie_);
    std::swap(querytype_, other->querytype_);
    std::swap(querydepth_, other->querydepth_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMGetLedger::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMGetLedger_descriptor_;
  metadata.reflection = TMGetLedger_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TMLedgerData::kLedgerHashFieldNumber;
const int TMLedgerData::kLedgerSeqFieldNumber;
const int TMLedgerData::kTypeFieldNumber;
const int TMLedgerData::kNodesFieldNumber;
const int TMLedgerData::kRequestCookieFieldNumber;
const int TMLedgerData::kErrorFieldNumber;
#endif  // !_MSC_VER

TMLedgerData::TMLedgerData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMLedgerData::InitAsDefaultInstance() {
}

TMLedgerData::TMLedgerData(const TMLedgerData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMLedgerData::SharedCtor() {
  _cached_size_ = 0;
  ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ledgerseq_ = 0u;
  type_ = 0;
  requestcookie_ = 0u;
  error_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMLedgerData::~TMLedgerData() {
  SharedDtor();
}

void TMLedgerData::SharedDtor() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (this != default_instance_) {
  }
}

void TMLedgerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMLedgerData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMLedgerData_descriptor_;
}

const TMLedgerData& TMLedgerData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMLedgerData* TMLedgerData::default_instance_ = NULL;

TMLedgerData* TMLedgerData::New() const {
  return new TMLedgerData;
}

void TMLedgerData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ledgerhash()) {
      if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
        ledgerhash_->clear();
      }
    }
    ledgerseq_ = 0u;
    type_ = 0;
    requestcookie_ = 0u;
    error_ = 1;
  }
  nodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMLedgerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ledgerHash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ledgerSeq;
        break;
      }

      // required uint32 ledgerSeq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ledgerSeq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
          set_has_ledgerseq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // required .protocol.TMLedgerInfoType type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerInfoType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMLedgerInfoType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nodes;
        break;
      }

      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nodes;
        if (input->ExpectTag(40)) goto parse_requestCookie;
        break;
      }

      // optional uint32 requestCookie = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_requestCookie:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &requestcookie_)));
          set_has_requestcookie();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_error;
        break;
      }

      // optional .protocol.TMReplyError error = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMReplyError_IsValid(value)) {
            set_error(static_cast< ::protocol::TMReplyError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMLedgerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes ledgerHash = 1;
  if (has_ledgerhash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->ledgerhash(), output);
  }

  // required uint32 ledgerSeq = 2;
  if (has_ledgerseq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ledgerseq(), output);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->nodes(i), output);
  }

  // optional uint32 requestCookie = 5;
  if (has_requestcookie()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->requestcookie(), output);
  }

  // optional .protocol.TMReplyError error = 6;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->error(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMLedgerData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes ledgerHash = 1;
  if (has_ledgerhash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->ledgerhash(), target);
  }

  // required uint32 ledgerSeq = 2;
  if (has_ledgerseq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ledgerseq(), target);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->nodes(i), target);
  }

  // optional uint32 requestCookie = 5;
  if (has_requestcookie()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->requestcookie(), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->error(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMLedgerData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes ledgerHash = 1;
    if (has_ledgerhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhash());
    }

    // required uint32 ledgerSeq = 2;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // required .protocol.TMLedgerInfoType type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 requestCookie = 5;
    if (has_requestcookie()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->requestcookie());
    }

    // optional .protocol.TMReplyError error = 6;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  // repeated .protocol.TMLedgerNode nodes = 4;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMLedgerData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMLedgerData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMLedgerData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMLedgerData::MergeFrom(const TMLedgerData& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ledgerhash()) {
      set_ledgerhash(from.ledgerhash());
    }
    if (from.has_ledgerseq()) {
      set_ledgerseq(from.ledgerseq());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_requestcookie()) {
      set_requestcookie(from.requestcookie());
    }
    if (from.has_error()) {
      set_error(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMLedgerData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerData::CopyFrom(const TMLedgerData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  for (int i = 0; i < nodes_size(); i++) {
    if (!this->nodes(i).IsInitialized()) return false;
  }
  return true;
}

void TMLedgerData::Swap(TMLedgerData* other) {
  if (other != this) {
    std::swap(ledgerhash_, other->ledgerhash_);
    std::swap(ledgerseq_, other->ledgerseq_);
    std::swap(type_, other->type_);
    nodes_.Swap(&other->nodes_);
    std::swap(requestcookie_, other->requestcookie_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMLedgerData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMLedgerData_descriptor_;
  metadata.reflection = TMLedgerData_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TMPing_pingType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMPing_pingType_descriptor_;
}
bool TMPing_pingType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TMPing_pingType TMPing::ptPING;
const TMPing_pingType TMPing::ptPONG;
const TMPing_pingType TMPing::pingType_MIN;
const TMPing_pingType TMPing::pingType_MAX;
const int TMPing::pingType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TMPing::kTypeFieldNumber;
const int TMPing::kSeqFieldNumber;
const int TMPing::kPingTimeFieldNumber;
const int TMPing::kNetTimeFieldNumber;
#endif  // !_MSC_VER

TMPing::TMPing()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TMPing::InitAsDefaultInstance() {
}

TMPing::TMPing(const TMPing& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TMPing::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  seq_ = 0u;
  pingtime_ = GOOGLE_ULONGLONG(0);
  nettime_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TMPing::~TMPing() {
  SharedDtor();
}

void TMPing::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TMPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMPing::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TMPing_descriptor_;
}

const TMPing& TMPing::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_skywell_2eproto();
  return *default_instance_;
}

TMPing* TMPing::default_instance_ = NULL;

TMPing* TMPing::New() const {
  return new TMPing;
}

void TMPing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    seq_ = 0u;
    pingtime_ = GOOGLE_ULONGLONG(0);
    nettime_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TMPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMPing.pingType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMPing_pingType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMPing_pingType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_seq;
        break;
      }

      // optional uint32 seq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pingTime;
        break;
      }

      // optional uint64 pingTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pingTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pingtime_)));
          set_has_pingtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_netTime;
        break;
      }

      // optional uint64 netTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_netTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nettime_)));
          set_has_nettime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TMPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .protocol.TMPing.pingType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 seq = 2;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->seq(), output);
  }

  // optional uint64 pingTime = 3;
  if (has_pingtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->pingtime(), output);
  }

  // optional uint64 netTime = 4;
  if (has_nettime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->nettime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TMPing::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .protocol.TMPing.pingType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint32 seq = 2;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->seq(), target);
  }

  // optional uint64 pingTime = 3;
  if (has_pingtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->pingtime(), target);
  }

  // optional uint64 netTime = 4;
  if (has_nettime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->nettime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TMPing::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .protocol.TMPing.pingType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 seq = 2;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seq());
    }

    // optional uint64 pingTime = 3;
    if (has_pingtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pingtime());
    }

    // optional uint64 netTime = 4;
    if (has_nettime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nettime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMPing::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TMPing* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TMPing*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TMPing::MergeFrom(const TMPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_pingtime()) {
      set_pingtime(from.pingtime());
    }
    if (from.has_nettime()) {
      set_nettime(from.nettime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TMPing::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPing::CopyFrom(const TMPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TMPing::Swap(TMPing* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(seq_, other->seq_);
    std::swap(pingtime_, other->pingtime_);
    std::swap(nettime_, other->nettime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TMPing::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TMPing_descriptor_;
  metadata.reflection = TMPing_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

// @@protoc_insertion_point(global_scope)
