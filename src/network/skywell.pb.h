// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: skywell.proto

#ifndef PROTOBUF_skywell_2eproto__INCLUDED
#define PROTOBUF_skywell_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_skywell_2eproto();
void protobuf_AssignDesc_skywell_2eproto();
void protobuf_ShutdownFile_skywell_2eproto();

class TMProofWork;
class TMHello;
class TMClusterNode;
class TMLoadSource;
class TMCluster;
class TMTransaction;
class TMStatusChange;
class TMProposeSet;
class TMHaveTransactionSet;
class TMValidation;
class TMGetPeers;
class TMIPv4Endpoint;
class TMPeers;
class TMEndpoint;
class TMEndpoints;
class TMIndexedObject;
class TMGetObjectByHash;
class TMLedgerNode;
class TMGetLedger;
class TMLedgerData;
class TMPing;

enum TMProofWork_PowResult {
  TMProofWork_PowResult_powrOK = 0,
  TMProofWork_PowResult_powrREUSED = 1,
  TMProofWork_PowResult_powrEXPIRED = 2,
  TMProofWork_PowResult_powrTOOEASY = 3,
  TMProofWork_PowResult_powrINVALID = 4,
  TMProofWork_PowResult_powrDISCONNECT = 5
};
bool TMProofWork_PowResult_IsValid(int value);
const TMProofWork_PowResult TMProofWork_PowResult_PowResult_MIN = TMProofWork_PowResult_powrOK;
const TMProofWork_PowResult TMProofWork_PowResult_PowResult_MAX = TMProofWork_PowResult_powrDISCONNECT;
const int TMProofWork_PowResult_PowResult_ARRAYSIZE = TMProofWork_PowResult_PowResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMProofWork_PowResult_descriptor();
inline const ::std::string& TMProofWork_PowResult_Name(TMProofWork_PowResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMProofWork_PowResult_descriptor(), value);
}
inline bool TMProofWork_PowResult_Parse(
    const ::std::string& name, TMProofWork_PowResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMProofWork_PowResult>(
    TMProofWork_PowResult_descriptor(), name, value);
}
enum TMGetObjectByHash_ObjectType {
  TMGetObjectByHash_ObjectType_otUNKNOWN = 0,
  TMGetObjectByHash_ObjectType_otLEDGER = 1,
  TMGetObjectByHash_ObjectType_otTRANSACTION = 2,
  TMGetObjectByHash_ObjectType_otTRANSACTION_NODE = 3,
  TMGetObjectByHash_ObjectType_otSTATE_NODE = 4,
  TMGetObjectByHash_ObjectType_otCAS_OBJECT = 5,
  TMGetObjectByHash_ObjectType_otFETCH_PACK = 6
};
bool TMGetObjectByHash_ObjectType_IsValid(int value);
const TMGetObjectByHash_ObjectType TMGetObjectByHash_ObjectType_ObjectType_MIN = TMGetObjectByHash_ObjectType_otUNKNOWN;
const TMGetObjectByHash_ObjectType TMGetObjectByHash_ObjectType_ObjectType_MAX = TMGetObjectByHash_ObjectType_otFETCH_PACK;
const int TMGetObjectByHash_ObjectType_ObjectType_ARRAYSIZE = TMGetObjectByHash_ObjectType_ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor();
inline const ::std::string& TMGetObjectByHash_ObjectType_Name(TMGetObjectByHash_ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMGetObjectByHash_ObjectType_descriptor(), value);
}
inline bool TMGetObjectByHash_ObjectType_Parse(
    const ::std::string& name, TMGetObjectByHash_ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMGetObjectByHash_ObjectType>(
    TMGetObjectByHash_ObjectType_descriptor(), name, value);
}
enum TMPing_pingType {
  TMPing_pingType_ptPING = 0,
  TMPing_pingType_ptPONG = 1
};
bool TMPing_pingType_IsValid(int value);
const TMPing_pingType TMPing_pingType_pingType_MIN = TMPing_pingType_ptPING;
const TMPing_pingType TMPing_pingType_pingType_MAX = TMPing_pingType_ptPONG;
const int TMPing_pingType_pingType_ARRAYSIZE = TMPing_pingType_pingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMPing_pingType_descriptor();
inline const ::std::string& TMPing_pingType_Name(TMPing_pingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMPing_pingType_descriptor(), value);
}
inline bool TMPing_pingType_Parse(
    const ::std::string& name, TMPing_pingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMPing_pingType>(
    TMPing_pingType_descriptor(), name, value);
}
enum MessageType {
  mtHELLO = 1,
  mtPING = 3,
  mtPROOFOFWORK = 4,
  mtCLUSTER = 5,
  mtGET_PEERS = 12,
  mtPEERS = 13,
  mtENDPOINTS = 15,
  mtTRANSACTION = 30,
  mtGET_LEDGER = 31,
  mtLEDGER_DATA = 32,
  mtPROPOSE_LEDGER = 33,
  mtSTATUS_CHANGE = 34,
  mtHAVE_SET = 35,
  mtVALIDATION = 41,
  mtGET_OBJECTS = 42
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = mtHELLO;
const MessageType MessageType_MAX = mtGET_OBJECTS;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum TransactionStatus {
  tsNEW = 1,
  tsCURRENT = 2,
  tsCOMMITED = 3,
  tsREJECT_CONFLICT = 4,
  tsREJECT_INVALID = 5,
  tsREJECT_FUNDS = 6,
  tsHELD_SEQ = 7,
  tsHELD_LEDGER = 8
};
bool TransactionStatus_IsValid(int value);
const TransactionStatus TransactionStatus_MIN = tsNEW;
const TransactionStatus TransactionStatus_MAX = tsHELD_LEDGER;
const int TransactionStatus_ARRAYSIZE = TransactionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransactionStatus_descriptor();
inline const ::std::string& TransactionStatus_Name(TransactionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransactionStatus_descriptor(), value);
}
inline bool TransactionStatus_Parse(
    const ::std::string& name, TransactionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransactionStatus>(
    TransactionStatus_descriptor(), name, value);
}
enum NodeStatus {
  nsCONNECTING = 1,
  nsCONNECTED = 2,
  nsMONITORING = 3,
  nsVALIDATING = 4,
  nsSHUTTING = 5
};
bool NodeStatus_IsValid(int value);
const NodeStatus NodeStatus_MIN = nsCONNECTING;
const NodeStatus NodeStatus_MAX = nsSHUTTING;
const int NodeStatus_ARRAYSIZE = NodeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeStatus_descriptor();
inline const ::std::string& NodeStatus_Name(NodeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeStatus_descriptor(), value);
}
inline bool NodeStatus_Parse(
    const ::std::string& name, NodeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStatus>(
    NodeStatus_descriptor(), name, value);
}
enum NodeEvent {
  neCLOSING_LEDGER = 1,
  neACCEPTED_LEDGER = 2,
  neSWITCHED_LEDGER = 3,
  neLOST_SYNC = 4
};
bool NodeEvent_IsValid(int value);
const NodeEvent NodeEvent_MIN = neCLOSING_LEDGER;
const NodeEvent NodeEvent_MAX = neLOST_SYNC;
const int NodeEvent_ARRAYSIZE = NodeEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeEvent_descriptor();
inline const ::std::string& NodeEvent_Name(NodeEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeEvent_descriptor(), value);
}
inline bool NodeEvent_Parse(
    const ::std::string& name, NodeEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeEvent>(
    NodeEvent_descriptor(), name, value);
}
enum TxSetStatus {
  tsHAVE = 1,
  tsCAN_GET = 2,
  tsNEED = 3
};
bool TxSetStatus_IsValid(int value);
const TxSetStatus TxSetStatus_MIN = tsHAVE;
const TxSetStatus TxSetStatus_MAX = tsNEED;
const int TxSetStatus_ARRAYSIZE = TxSetStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxSetStatus_descriptor();
inline const ::std::string& TxSetStatus_Name(TxSetStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxSetStatus_descriptor(), value);
}
inline bool TxSetStatus_Parse(
    const ::std::string& name, TxSetStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxSetStatus>(
    TxSetStatus_descriptor(), name, value);
}
enum TMLedgerInfoType {
  liBASE = 0,
  liTX_NODE = 1,
  liAS_NODE = 2,
  liTS_CANDIDATE = 3
};
bool TMLedgerInfoType_IsValid(int value);
const TMLedgerInfoType TMLedgerInfoType_MIN = liBASE;
const TMLedgerInfoType TMLedgerInfoType_MAX = liTS_CANDIDATE;
const int TMLedgerInfoType_ARRAYSIZE = TMLedgerInfoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMLedgerInfoType_descriptor();
inline const ::std::string& TMLedgerInfoType_Name(TMLedgerInfoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMLedgerInfoType_descriptor(), value);
}
inline bool TMLedgerInfoType_Parse(
    const ::std::string& name, TMLedgerInfoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMLedgerInfoType>(
    TMLedgerInfoType_descriptor(), name, value);
}
enum TMLedgerType {
  ltACCEPTED = 0,
  ltCURRENT = 1,
  ltCLOSED = 2
};
bool TMLedgerType_IsValid(int value);
const TMLedgerType TMLedgerType_MIN = ltACCEPTED;
const TMLedgerType TMLedgerType_MAX = ltCLOSED;
const int TMLedgerType_ARRAYSIZE = TMLedgerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMLedgerType_descriptor();
inline const ::std::string& TMLedgerType_Name(TMLedgerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMLedgerType_descriptor(), value);
}
inline bool TMLedgerType_Parse(
    const ::std::string& name, TMLedgerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMLedgerType>(
    TMLedgerType_descriptor(), name, value);
}
enum TMQueryType {
  qtINDIRECT = 0
};
bool TMQueryType_IsValid(int value);
const TMQueryType TMQueryType_MIN = qtINDIRECT;
const TMQueryType TMQueryType_MAX = qtINDIRECT;
const int TMQueryType_ARRAYSIZE = TMQueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMQueryType_descriptor();
inline const ::std::string& TMQueryType_Name(TMQueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMQueryType_descriptor(), value);
}
inline bool TMQueryType_Parse(
    const ::std::string& name, TMQueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMQueryType>(
    TMQueryType_descriptor(), name, value);
}
enum TMReplyError {
  reNO_LEDGER = 1,
  reNO_NODE = 2
};
bool TMReplyError_IsValid(int value);
const TMReplyError TMReplyError_MIN = reNO_LEDGER;
const TMReplyError TMReplyError_MAX = reNO_NODE;
const int TMReplyError_ARRAYSIZE = TMReplyError_MAX + 1;

const ::google::protobuf::EnumDescriptor* TMReplyError_descriptor();
inline const ::std::string& TMReplyError_Name(TMReplyError value) {
  return ::google::protobuf::internal::NameOfEnum(
    TMReplyError_descriptor(), value);
}
inline bool TMReplyError_Parse(
    const ::std::string& name, TMReplyError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TMReplyError>(
    TMReplyError_descriptor(), name, value);
}
// ===================================================================

class TMProofWork : public ::google::protobuf::Message {
 public:
  TMProofWork();
  virtual ~TMProofWork();

  TMProofWork(const TMProofWork& from);

  inline TMProofWork& operator=(const TMProofWork& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMProofWork& default_instance();

  void Swap(TMProofWork* other);

  // implements Message ----------------------------------------------

  TMProofWork* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMProofWork& from);
  void MergeFrom(const TMProofWork& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TMProofWork_PowResult PowResult;
  static const PowResult powrOK = TMProofWork_PowResult_powrOK;
  static const PowResult powrREUSED = TMProofWork_PowResult_powrREUSED;
  static const PowResult powrEXPIRED = TMProofWork_PowResult_powrEXPIRED;
  static const PowResult powrTOOEASY = TMProofWork_PowResult_powrTOOEASY;
  static const PowResult powrINVALID = TMProofWork_PowResult_powrINVALID;
  static const PowResult powrDISCONNECT = TMProofWork_PowResult_powrDISCONNECT;
  static inline bool PowResult_IsValid(int value) {
    return TMProofWork_PowResult_IsValid(value);
  }
  static const PowResult PowResult_MIN =
    TMProofWork_PowResult_PowResult_MIN;
  static const PowResult PowResult_MAX =
    TMProofWork_PowResult_PowResult_MAX;
  static const int PowResult_ARRAYSIZE =
    TMProofWork_PowResult_PowResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PowResult_descriptor() {
    return TMProofWork_PowResult_descriptor();
  }
  static inline const ::std::string& PowResult_Name(PowResult value) {
    return TMProofWork_PowResult_Name(value);
  }
  static inline bool PowResult_Parse(const ::std::string& name,
      PowResult* value) {
    return TMProofWork_PowResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 iterations = 2;
  inline bool has_iterations() const;
  inline void clear_iterations();
  static const int kIterationsFieldNumber = 2;
  inline ::google::protobuf::uint32 iterations() const;
  inline void set_iterations(::google::protobuf::uint32 value);

  // optional bytes target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const void* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // optional bytes challenge = 4;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 4;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const void* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  inline void set_allocated_challenge(::std::string* challenge);

  // optional bytes response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  inline void set_allocated_response(::std::string* response);

  // optional .protocol.TMProofWork.PowResult result = 6;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 6;
  inline ::protocol::TMProofWork_PowResult result() const;
  inline void set_result(::protocol::TMProofWork_PowResult value);

  // @@protoc_insertion_point(class_scope:protocol.TMProofWork)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_iterations();
  inline void clear_has_iterations();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_challenge();
  inline void clear_has_challenge();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* target_;
  ::std::string* challenge_;
  ::google::protobuf::uint32 iterations_;
  int result_;
  ::std::string* response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMProofWork* default_instance_;
};
// -------------------------------------------------------------------

class TMHello : public ::google::protobuf::Message {
 public:
  TMHello();
  virtual ~TMHello();

  TMHello(const TMHello& from);

  inline TMHello& operator=(const TMHello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMHello& default_instance();

  void Swap(TMHello* other);

  // implements Message ----------------------------------------------

  TMHello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMHello& from);
  void MergeFrom(const TMHello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 protoVersion = 1;
  inline bool has_protoversion() const;
  inline void clear_protoversion();
  static const int kProtoVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protoversion() const;
  inline void set_protoversion(::google::protobuf::uint32 value);

  // required uint32 protoVersionMin = 2;
  inline bool has_protoversionmin() const;
  inline void clear_protoversionmin();
  static const int kProtoVersionMinFieldNumber = 2;
  inline ::google::protobuf::uint32 protoversionmin() const;
  inline void set_protoversionmin(::google::protobuf::uint32 value);

  // required bytes nodePublic = 3;
  inline bool has_nodepublic() const;
  inline void clear_nodepublic();
  static const int kNodePublicFieldNumber = 3;
  inline const ::std::string& nodepublic() const;
  inline void set_nodepublic(const ::std::string& value);
  inline void set_nodepublic(const char* value);
  inline void set_nodepublic(const void* value, size_t size);
  inline ::std::string* mutable_nodepublic();
  inline ::std::string* release_nodepublic();
  inline void set_allocated_nodepublic(::std::string* nodepublic);

  // required bytes nodeProof = 4;
  inline bool has_nodeproof() const;
  inline void clear_nodeproof();
  static const int kNodeProofFieldNumber = 4;
  inline const ::std::string& nodeproof() const;
  inline void set_nodeproof(const ::std::string& value);
  inline void set_nodeproof(const char* value);
  inline void set_nodeproof(const void* value, size_t size);
  inline ::std::string* mutable_nodeproof();
  inline ::std::string* release_nodeproof();
  inline void set_allocated_nodeproof(::std::string* nodeproof);

  // optional string fullVersion = 5;
  inline bool has_fullversion() const;
  inline void clear_fullversion();
  static const int kFullVersionFieldNumber = 5;
  inline const ::std::string& fullversion() const;
  inline void set_fullversion(const ::std::string& value);
  inline void set_fullversion(const char* value);
  inline void set_fullversion(const char* value, size_t size);
  inline ::std::string* mutable_fullversion();
  inline ::std::string* release_fullversion();
  inline void set_allocated_fullversion(::std::string* fullversion);

  // optional uint64 netTime = 6;
  inline bool has_nettime() const;
  inline void clear_nettime();
  static const int kNetTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 nettime() const;
  inline void set_nettime(::google::protobuf::uint64 value);

  // optional uint32 ipv4Port = 7;
  inline bool has_ipv4port() const;
  inline void clear_ipv4port();
  static const int kIpv4PortFieldNumber = 7;
  inline ::google::protobuf::uint32 ipv4port() const;
  inline void set_ipv4port(::google::protobuf::uint32 value);

  // optional uint32 ledgerIndex = 8;
  inline bool has_ledgerindex() const;
  inline void clear_ledgerindex();
  static const int kLedgerIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 ledgerindex() const;
  inline void set_ledgerindex(::google::protobuf::uint32 value);

  // optional bytes ledgerClosed = 9;
  inline bool has_ledgerclosed() const;
  inline void clear_ledgerclosed();
  static const int kLedgerClosedFieldNumber = 9;
  inline const ::std::string& ledgerclosed() const;
  inline void set_ledgerclosed(const ::std::string& value);
  inline void set_ledgerclosed(const char* value);
  inline void set_ledgerclosed(const void* value, size_t size);
  inline ::std::string* mutable_ledgerclosed();
  inline ::std::string* release_ledgerclosed();
  inline void set_allocated_ledgerclosed(::std::string* ledgerclosed);

  // optional bytes ledgerPrevious = 10;
  inline bool has_ledgerprevious() const;
  inline void clear_ledgerprevious();
  static const int kLedgerPreviousFieldNumber = 10;
  inline const ::std::string& ledgerprevious() const;
  inline void set_ledgerprevious(const ::std::string& value);
  inline void set_ledgerprevious(const char* value);
  inline void set_ledgerprevious(const void* value, size_t size);
  inline ::std::string* mutable_ledgerprevious();
  inline ::std::string* release_ledgerprevious();
  inline void set_allocated_ledgerprevious(::std::string* ledgerprevious);

  // optional bool nodePrivate = 11;
  inline bool has_nodeprivate() const;
  inline void clear_nodeprivate();
  static const int kNodePrivateFieldNumber = 11;
  inline bool nodeprivate() const;
  inline void set_nodeprivate(bool value);

  // optional .protocol.TMProofWork proofOfWork = 12;
  inline bool has_proofofwork() const;
  inline void clear_proofofwork();
  static const int kProofOfWorkFieldNumber = 12;
  inline const ::protocol::TMProofWork& proofofwork() const;
  inline ::protocol::TMProofWork* mutable_proofofwork();
  inline ::protocol::TMProofWork* release_proofofwork();
  inline void set_allocated_proofofwork(::protocol::TMProofWork* proofofwork);

  // optional bool testNet = 13;
  inline bool has_testnet() const;
  inline void clear_testnet();
  static const int kTestNetFieldNumber = 13;
  inline bool testnet() const;
  inline void set_testnet(bool value);

  // @@protoc_insertion_point(class_scope:protocol.TMHello)
 private:
  inline void set_has_protoversion();
  inline void clear_has_protoversion();
  inline void set_has_protoversionmin();
  inline void clear_has_protoversionmin();
  inline void set_has_nodepublic();
  inline void clear_has_nodepublic();
  inline void set_has_nodeproof();
  inline void clear_has_nodeproof();
  inline void set_has_fullversion();
  inline void clear_has_fullversion();
  inline void set_has_nettime();
  inline void clear_has_nettime();
  inline void set_has_ipv4port();
  inline void clear_has_ipv4port();
  inline void set_has_ledgerindex();
  inline void clear_has_ledgerindex();
  inline void set_has_ledgerclosed();
  inline void clear_has_ledgerclosed();
  inline void set_has_ledgerprevious();
  inline void clear_has_ledgerprevious();
  inline void set_has_nodeprivate();
  inline void clear_has_nodeprivate();
  inline void set_has_proofofwork();
  inline void clear_has_proofofwork();
  inline void set_has_testnet();
  inline void clear_has_testnet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 protoversion_;
  ::google::protobuf::uint32 protoversionmin_;
  ::std::string* nodepublic_;
  ::std::string* nodeproof_;
  ::std::string* fullversion_;
  ::google::protobuf::uint64 nettime_;
  ::google::protobuf::uint32 ipv4port_;
  ::google::protobuf::uint32 ledgerindex_;
  ::std::string* ledgerclosed_;
  ::std::string* ledgerprevious_;
  ::protocol::TMProofWork* proofofwork_;
  bool nodeprivate_;
  bool testnet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMHello* default_instance_;
};
// -------------------------------------------------------------------

class TMClusterNode : public ::google::protobuf::Message {
 public:
  TMClusterNode();
  virtual ~TMClusterNode();

  TMClusterNode(const TMClusterNode& from);

  inline TMClusterNode& operator=(const TMClusterNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMClusterNode& default_instance();

  void Swap(TMClusterNode* other);

  // implements Message ----------------------------------------------

  TMClusterNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMClusterNode& from);
  void MergeFrom(const TMClusterNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string publicKey = 1;
  inline bool has_publickey() const;
  inline void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& publickey() const;
  inline void set_publickey(const ::std::string& value);
  inline void set_publickey(const char* value);
  inline void set_publickey(const char* value, size_t size);
  inline ::std::string* mutable_publickey();
  inline ::std::string* release_publickey();
  inline void set_allocated_publickey(::std::string* publickey);

  // required uint32 reportTime = 2;
  inline bool has_reporttime() const;
  inline void clear_reporttime();
  static const int kReportTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 reporttime() const;
  inline void set_reporttime(::google::protobuf::uint32 value);

  // required uint32 nodeLoad = 3;
  inline bool has_nodeload() const;
  inline void clear_nodeload();
  static const int kNodeLoadFieldNumber = 3;
  inline ::google::protobuf::uint32 nodeload() const;
  inline void set_nodeload(::google::protobuf::uint32 value);

  // optional string nodeName = 4;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 4;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:protocol.TMClusterNode)
 private:
  inline void set_has_publickey();
  inline void clear_has_publickey();
  inline void set_has_reporttime();
  inline void clear_has_reporttime();
  inline void set_has_nodeload();
  inline void clear_has_nodeload();
  inline void set_has_nodename();
  inline void clear_has_nodename();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publickey_;
  ::google::protobuf::uint32 reporttime_;
  ::google::protobuf::uint32 nodeload_;
  ::std::string* nodename_;
  ::std::string* address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMClusterNode* default_instance_;
};
// -------------------------------------------------------------------

class TMLoadSource : public ::google::protobuf::Message {
 public:
  TMLoadSource();
  virtual ~TMLoadSource();

  TMLoadSource(const TMLoadSource& from);

  inline TMLoadSource& operator=(const TMLoadSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMLoadSource& default_instance();

  void Swap(TMLoadSource* other);

  // implements Message ----------------------------------------------

  TMLoadSource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMLoadSource& from);
  void MergeFrom(const TMLoadSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 cost = 2;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 2;
  inline ::google::protobuf::uint32 cost() const;
  inline void set_cost(::google::protobuf::uint32 value);

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMLoadSource)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_cost();
  inline void clear_has_cost();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 cost_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMLoadSource* default_instance_;
};
// -------------------------------------------------------------------

class TMCluster : public ::google::protobuf::Message {
 public:
  TMCluster();
  virtual ~TMCluster();

  TMCluster(const TMCluster& from);

  inline TMCluster& operator=(const TMCluster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMCluster& default_instance();

  void Swap(TMCluster* other);

  // implements Message ----------------------------------------------

  TMCluster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMCluster& from);
  void MergeFrom(const TMCluster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  inline int clusternodes_size() const;
  inline void clear_clusternodes();
  static const int kClusterNodesFieldNumber = 1;
  inline const ::protocol::TMClusterNode& clusternodes(int index) const;
  inline ::protocol::TMClusterNode* mutable_clusternodes(int index);
  inline ::protocol::TMClusterNode* add_clusternodes();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMClusterNode >&
      clusternodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::TMClusterNode >*
      mutable_clusternodes();

  // repeated .protocol.TMLoadSource loadSources = 2;
  inline int loadsources_size() const;
  inline void clear_loadsources();
  static const int kLoadSourcesFieldNumber = 2;
  inline const ::protocol::TMLoadSource& loadsources(int index) const;
  inline ::protocol::TMLoadSource* mutable_loadsources(int index);
  inline ::protocol::TMLoadSource* add_loadsources();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMLoadSource >&
      loadsources() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::TMLoadSource >*
      mutable_loadsources();

  // @@protoc_insertion_point(class_scope:protocol.TMCluster)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocol::TMClusterNode > clusternodes_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TMLoadSource > loadsources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMCluster* default_instance_;
};
// -------------------------------------------------------------------

class TMTransaction : public ::google::protobuf::Message {
 public:
  TMTransaction();
  virtual ~TMTransaction();

  TMTransaction(const TMTransaction& from);

  inline TMTransaction& operator=(const TMTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMTransaction& default_instance();

  void Swap(TMTransaction* other);

  // implements Message ----------------------------------------------

  TMTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMTransaction& from);
  void MergeFrom(const TMTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes rawTransaction = 1;
  inline bool has_rawtransaction() const;
  inline void clear_rawtransaction();
  static const int kRawTransactionFieldNumber = 1;
  inline const ::std::string& rawtransaction() const;
  inline void set_rawtransaction(const ::std::string& value);
  inline void set_rawtransaction(const char* value);
  inline void set_rawtransaction(const void* value, size_t size);
  inline ::std::string* mutable_rawtransaction();
  inline ::std::string* release_rawtransaction();
  inline void set_allocated_rawtransaction(::std::string* rawtransaction);

  // required .protocol.TransactionStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::protocol::TransactionStatus status() const;
  inline void set_status(::protocol::TransactionStatus value);

  // optional uint64 receiveTimestamp = 3;
  inline bool has_receivetimestamp() const;
  inline void clear_receivetimestamp();
  static const int kReceiveTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 receivetimestamp() const;
  inline void set_receivetimestamp(::google::protobuf::uint64 value);

  // optional bool deferred = 4;
  inline bool has_deferred() const;
  inline void clear_deferred();
  static const int kDeferredFieldNumber = 4;
  inline bool deferred() const;
  inline void set_deferred(bool value);

  // @@protoc_insertion_point(class_scope:protocol.TMTransaction)
 private:
  inline void set_has_rawtransaction();
  inline void clear_has_rawtransaction();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_receivetimestamp();
  inline void clear_has_receivetimestamp();
  inline void set_has_deferred();
  inline void clear_has_deferred();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rawtransaction_;
  ::google::protobuf::uint64 receivetimestamp_;
  int status_;
  bool deferred_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMTransaction* default_instance_;
};
// -------------------------------------------------------------------

class TMStatusChange : public ::google::protobuf::Message {
 public:
  TMStatusChange();
  virtual ~TMStatusChange();

  TMStatusChange(const TMStatusChange& from);

  inline TMStatusChange& operator=(const TMStatusChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMStatusChange& default_instance();

  void Swap(TMStatusChange* other);

  // implements Message ----------------------------------------------

  TMStatusChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMStatusChange& from);
  void MergeFrom(const TMStatusChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.NodeStatus newStatus = 1;
  inline bool has_newstatus() const;
  inline void clear_newstatus();
  static const int kNewStatusFieldNumber = 1;
  inline ::protocol::NodeStatus newstatus() const;
  inline void set_newstatus(::protocol::NodeStatus value);

  // optional .protocol.NodeEvent newEvent = 2;
  inline bool has_newevent() const;
  inline void clear_newevent();
  static const int kNewEventFieldNumber = 2;
  inline ::protocol::NodeEvent newevent() const;
  inline void set_newevent(::protocol::NodeEvent value);

  // optional uint32 ledgerSeq = 3;
  inline bool has_ledgerseq() const;
  inline void clear_ledgerseq();
  static const int kLedgerSeqFieldNumber = 3;
  inline ::google::protobuf::uint32 ledgerseq() const;
  inline void set_ledgerseq(::google::protobuf::uint32 value);

  // optional bytes ledgerHash = 4;
  inline bool has_ledgerhash() const;
  inline void clear_ledgerhash();
  static const int kLedgerHashFieldNumber = 4;
  inline const ::std::string& ledgerhash() const;
  inline void set_ledgerhash(const ::std::string& value);
  inline void set_ledgerhash(const char* value);
  inline void set_ledgerhash(const void* value, size_t size);
  inline ::std::string* mutable_ledgerhash();
  inline ::std::string* release_ledgerhash();
  inline void set_allocated_ledgerhash(::std::string* ledgerhash);

  // optional bytes ledgerHashPrevious = 5;
  inline bool has_ledgerhashprevious() const;
  inline void clear_ledgerhashprevious();
  static const int kLedgerHashPreviousFieldNumber = 5;
  inline const ::std::string& ledgerhashprevious() const;
  inline void set_ledgerhashprevious(const ::std::string& value);
  inline void set_ledgerhashprevious(const char* value);
  inline void set_ledgerhashprevious(const void* value, size_t size);
  inline ::std::string* mutable_ledgerhashprevious();
  inline ::std::string* release_ledgerhashprevious();
  inline void set_allocated_ledgerhashprevious(::std::string* ledgerhashprevious);

  // optional uint64 networkTime = 6;
  inline bool has_networktime() const;
  inline void clear_networktime();
  static const int kNetworkTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 networktime() const;
  inline void set_networktime(::google::protobuf::uint64 value);

  // optional uint32 firstSeq = 7;
  inline bool has_firstseq() const;
  inline void clear_firstseq();
  static const int kFirstSeqFieldNumber = 7;
  inline ::google::protobuf::uint32 firstseq() const;
  inline void set_firstseq(::google::protobuf::uint32 value);

  // optional uint32 lastSeq = 8;
  inline bool has_lastseq() const;
  inline void clear_lastseq();
  static const int kLastSeqFieldNumber = 8;
  inline ::google::protobuf::uint32 lastseq() const;
  inline void set_lastseq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMStatusChange)
 private:
  inline void set_has_newstatus();
  inline void clear_has_newstatus();
  inline void set_has_newevent();
  inline void clear_has_newevent();
  inline void set_has_ledgerseq();
  inline void clear_has_ledgerseq();
  inline void set_has_ledgerhash();
  inline void clear_has_ledgerhash();
  inline void set_has_ledgerhashprevious();
  inline void clear_has_ledgerhashprevious();
  inline void set_has_networktime();
  inline void clear_has_networktime();
  inline void set_has_firstseq();
  inline void clear_has_firstseq();
  inline void set_has_lastseq();
  inline void clear_has_lastseq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int newstatus_;
  int newevent_;
  ::std::string* ledgerhash_;
  ::std::string* ledgerhashprevious_;
  ::google::protobuf::uint32 ledgerseq_;
  ::google::protobuf::uint32 firstseq_;
  ::google::protobuf::uint64 networktime_;
  ::google::protobuf::uint32 lastseq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMStatusChange* default_instance_;
};
// -------------------------------------------------------------------

class TMProposeSet : public ::google::protobuf::Message {
 public:
  TMProposeSet();
  virtual ~TMProposeSet();

  TMProposeSet(const TMProposeSet& from);

  inline TMProposeSet& operator=(const TMProposeSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMProposeSet& default_instance();

  void Swap(TMProposeSet* other);

  // implements Message ----------------------------------------------

  TMProposeSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMProposeSet& from);
  void MergeFrom(const TMProposeSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 proposeSeq = 1;
  inline bool has_proposeseq() const;
  inline void clear_proposeseq();
  static const int kProposeSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 proposeseq() const;
  inline void set_proposeseq(::google::protobuf::uint32 value);

  // required bytes currentTxHash = 2;
  inline bool has_currenttxhash() const;
  inline void clear_currenttxhash();
  static const int kCurrentTxHashFieldNumber = 2;
  inline const ::std::string& currenttxhash() const;
  inline void set_currenttxhash(const ::std::string& value);
  inline void set_currenttxhash(const char* value);
  inline void set_currenttxhash(const void* value, size_t size);
  inline ::std::string* mutable_currenttxhash();
  inline ::std::string* release_currenttxhash();
  inline void set_allocated_currenttxhash(::std::string* currenttxhash);

  // required bytes nodePubKey = 3;
  inline bool has_nodepubkey() const;
  inline void clear_nodepubkey();
  static const int kNodePubKeyFieldNumber = 3;
  inline const ::std::string& nodepubkey() const;
  inline void set_nodepubkey(const ::std::string& value);
  inline void set_nodepubkey(const char* value);
  inline void set_nodepubkey(const void* value, size_t size);
  inline ::std::string* mutable_nodepubkey();
  inline ::std::string* release_nodepubkey();
  inline void set_allocated_nodepubkey(::std::string* nodepubkey);

  // required uint32 closeTime = 4;
  inline bool has_closetime() const;
  inline void clear_closetime();
  static const int kCloseTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 closetime() const;
  inline void set_closetime(::google::protobuf::uint32 value);

  // required bytes signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes previousledger = 6;
  inline bool has_previousledger() const;
  inline void clear_previousledger();
  static const int kPreviousledgerFieldNumber = 6;
  inline const ::std::string& previousledger() const;
  inline void set_previousledger(const ::std::string& value);
  inline void set_previousledger(const char* value);
  inline void set_previousledger(const void* value, size_t size);
  inline ::std::string* mutable_previousledger();
  inline ::std::string* release_previousledger();
  inline void set_allocated_previousledger(::std::string* previousledger);

  // optional bool checkedSignature = 7;
  inline bool has_checkedsignature() const;
  inline void clear_checkedsignature();
  static const int kCheckedSignatureFieldNumber = 7;
  inline bool checkedsignature() const;
  inline void set_checkedsignature(bool value);

  // repeated bytes addedTransactions = 10;
  inline int addedtransactions_size() const;
  inline void clear_addedtransactions();
  static const int kAddedTransactionsFieldNumber = 10;
  inline const ::std::string& addedtransactions(int index) const;
  inline ::std::string* mutable_addedtransactions(int index);
  inline void set_addedtransactions(int index, const ::std::string& value);
  inline void set_addedtransactions(int index, const char* value);
  inline void set_addedtransactions(int index, const void* value, size_t size);
  inline ::std::string* add_addedtransactions();
  inline void add_addedtransactions(const ::std::string& value);
  inline void add_addedtransactions(const char* value);
  inline void add_addedtransactions(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& addedtransactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addedtransactions();

  // repeated bytes removedTransactions = 11;
  inline int removedtransactions_size() const;
  inline void clear_removedtransactions();
  static const int kRemovedTransactionsFieldNumber = 11;
  inline const ::std::string& removedtransactions(int index) const;
  inline ::std::string* mutable_removedtransactions(int index);
  inline void set_removedtransactions(int index, const ::std::string& value);
  inline void set_removedtransactions(int index, const char* value);
  inline void set_removedtransactions(int index, const void* value, size_t size);
  inline ::std::string* add_removedtransactions();
  inline void add_removedtransactions(const ::std::string& value);
  inline void add_removedtransactions(const char* value);
  inline void add_removedtransactions(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& removedtransactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_removedtransactions();

  // optional uint32 hops = 12;
  inline bool has_hops() const;
  inline void clear_hops();
  static const int kHopsFieldNumber = 12;
  inline ::google::protobuf::uint32 hops() const;
  inline void set_hops(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMProposeSet)
 private:
  inline void set_has_proposeseq();
  inline void clear_has_proposeseq();
  inline void set_has_currenttxhash();
  inline void clear_has_currenttxhash();
  inline void set_has_nodepubkey();
  inline void clear_has_nodepubkey();
  inline void set_has_closetime();
  inline void clear_has_closetime();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_previousledger();
  inline void clear_has_previousledger();
  inline void set_has_checkedsignature();
  inline void clear_has_checkedsignature();
  inline void set_has_hops();
  inline void clear_has_hops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* currenttxhash_;
  ::google::protobuf::uint32 proposeseq_;
  ::google::protobuf::uint32 closetime_;
  ::std::string* nodepubkey_;
  ::std::string* signature_;
  ::std::string* previousledger_;
  ::google::protobuf::RepeatedPtrField< ::std::string> addedtransactions_;
  bool checkedsignature_;
  ::google::protobuf::uint32 hops_;
  ::google::protobuf::RepeatedPtrField< ::std::string> removedtransactions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMProposeSet* default_instance_;
};
// -------------------------------------------------------------------

class TMHaveTransactionSet : public ::google::protobuf::Message {
 public:
  TMHaveTransactionSet();
  virtual ~TMHaveTransactionSet();

  TMHaveTransactionSet(const TMHaveTransactionSet& from);

  inline TMHaveTransactionSet& operator=(const TMHaveTransactionSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMHaveTransactionSet& default_instance();

  void Swap(TMHaveTransactionSet* other);

  // implements Message ----------------------------------------------

  TMHaveTransactionSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMHaveTransactionSet& from);
  void MergeFrom(const TMHaveTransactionSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.TxSetStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::protocol::TxSetStatus status() const;
  inline void set_status(::protocol::TxSetStatus value);

  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:protocol.TMHaveTransactionSet)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_hash();
  inline void clear_has_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hash_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMHaveTransactionSet* default_instance_;
};
// -------------------------------------------------------------------

class TMValidation : public ::google::protobuf::Message {
 public:
  TMValidation();
  virtual ~TMValidation();

  TMValidation(const TMValidation& from);

  inline TMValidation& operator=(const TMValidation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMValidation& default_instance();

  void Swap(TMValidation* other);

  // implements Message ----------------------------------------------

  TMValidation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMValidation& from);
  void MergeFrom(const TMValidation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes validation = 1;
  inline bool has_validation() const;
  inline void clear_validation();
  static const int kValidationFieldNumber = 1;
  inline const ::std::string& validation() const;
  inline void set_validation(const ::std::string& value);
  inline void set_validation(const char* value);
  inline void set_validation(const void* value, size_t size);
  inline ::std::string* mutable_validation();
  inline ::std::string* release_validation();
  inline void set_allocated_validation(::std::string* validation);

  // optional bool checkedSignature = 2;
  inline bool has_checkedsignature() const;
  inline void clear_checkedsignature();
  static const int kCheckedSignatureFieldNumber = 2;
  inline bool checkedsignature() const;
  inline void set_checkedsignature(bool value);

  // optional uint32 hops = 3;
  inline bool has_hops() const;
  inline void clear_hops();
  static const int kHopsFieldNumber = 3;
  inline ::google::protobuf::uint32 hops() const;
  inline void set_hops(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMValidation)
 private:
  inline void set_has_validation();
  inline void clear_has_validation();
  inline void set_has_checkedsignature();
  inline void clear_has_checkedsignature();
  inline void set_has_hops();
  inline void clear_has_hops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* validation_;
  bool checkedsignature_;
  ::google::protobuf::uint32 hops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMValidation* default_instance_;
};
// -------------------------------------------------------------------

class TMGetPeers : public ::google::protobuf::Message {
 public:
  TMGetPeers();
  virtual ~TMGetPeers();

  TMGetPeers(const TMGetPeers& from);

  inline TMGetPeers& operator=(const TMGetPeers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMGetPeers& default_instance();

  void Swap(TMGetPeers* other);

  // implements Message ----------------------------------------------

  TMGetPeers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMGetPeers& from);
  void MergeFrom(const TMGetPeers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 doWeNeedThis = 1;
  inline bool has_doweneedthis() const;
  inline void clear_doweneedthis();
  static const int kDoWeNeedThisFieldNumber = 1;
  inline ::google::protobuf::uint32 doweneedthis() const;
  inline void set_doweneedthis(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMGetPeers)
 private:
  inline void set_has_doweneedthis();
  inline void clear_has_doweneedthis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 doweneedthis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMGetPeers* default_instance_;
};
// -------------------------------------------------------------------

class TMIPv4Endpoint : public ::google::protobuf::Message {
 public:
  TMIPv4Endpoint();
  virtual ~TMIPv4Endpoint();

  TMIPv4Endpoint(const TMIPv4Endpoint& from);

  inline TMIPv4Endpoint& operator=(const TMIPv4Endpoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMIPv4Endpoint& default_instance();

  void Swap(TMIPv4Endpoint* other);

  // implements Message ----------------------------------------------

  TMIPv4Endpoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMIPv4Endpoint& from);
  void MergeFrom(const TMIPv4Endpoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ipv4 = 1;
  inline bool has_ipv4() const;
  inline void clear_ipv4();
  static const int kIpv4FieldNumber = 1;
  inline ::google::protobuf::uint32 ipv4() const;
  inline void set_ipv4(::google::protobuf::uint32 value);

  // required uint32 ipv4Port = 2;
  inline bool has_ipv4port() const;
  inline void clear_ipv4port();
  static const int kIpv4PortFieldNumber = 2;
  inline ::google::protobuf::uint32 ipv4port() const;
  inline void set_ipv4port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMIPv4Endpoint)
 private:
  inline void set_has_ipv4();
  inline void clear_has_ipv4();
  inline void set_has_ipv4port();
  inline void clear_has_ipv4port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ipv4_;
  ::google::protobuf::uint32 ipv4port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMIPv4Endpoint* default_instance_;
};
// -------------------------------------------------------------------

class TMPeers : public ::google::protobuf::Message {
 public:
  TMPeers();
  virtual ~TMPeers();

  TMPeers(const TMPeers& from);

  inline TMPeers& operator=(const TMPeers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMPeers& default_instance();

  void Swap(TMPeers* other);

  // implements Message ----------------------------------------------

  TMPeers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMPeers& from);
  void MergeFrom(const TMPeers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::protocol::TMIPv4Endpoint& nodes(int index) const;
  inline ::protocol::TMIPv4Endpoint* mutable_nodes(int index);
  inline ::protocol::TMIPv4Endpoint* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMIPv4Endpoint >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::TMIPv4Endpoint >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:protocol.TMPeers)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocol::TMIPv4Endpoint > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMPeers* default_instance_;
};
// -------------------------------------------------------------------

class TMEndpoint : public ::google::protobuf::Message {
 public:
  TMEndpoint();
  virtual ~TMEndpoint();

  TMEndpoint(const TMEndpoint& from);

  inline TMEndpoint& operator=(const TMEndpoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMEndpoint& default_instance();

  void Swap(TMEndpoint* other);

  // implements Message ----------------------------------------------

  TMEndpoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMEndpoint& from);
  void MergeFrom(const TMEndpoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.TMIPv4Endpoint ipv4 = 1;
  inline bool has_ipv4() const;
  inline void clear_ipv4();
  static const int kIpv4FieldNumber = 1;
  inline const ::protocol::TMIPv4Endpoint& ipv4() const;
  inline ::protocol::TMIPv4Endpoint* mutable_ipv4();
  inline ::protocol::TMIPv4Endpoint* release_ipv4();
  inline void set_allocated_ipv4(::protocol::TMIPv4Endpoint* ipv4);

  // required uint32 hops = 2;
  inline bool has_hops() const;
  inline void clear_hops();
  static const int kHopsFieldNumber = 2;
  inline ::google::protobuf::uint32 hops() const;
  inline void set_hops(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMEndpoint)
 private:
  inline void set_has_ipv4();
  inline void clear_has_ipv4();
  inline void set_has_hops();
  inline void clear_has_hops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::TMIPv4Endpoint* ipv4_;
  ::google::protobuf::uint32 hops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMEndpoint* default_instance_;
};
// -------------------------------------------------------------------

class TMEndpoints : public ::google::protobuf::Message {
 public:
  TMEndpoints();
  virtual ~TMEndpoints();

  TMEndpoints(const TMEndpoints& from);

  inline TMEndpoints& operator=(const TMEndpoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMEndpoints& default_instance();

  void Swap(TMEndpoints* other);

  // implements Message ----------------------------------------------

  TMEndpoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMEndpoints& from);
  void MergeFrom(const TMEndpoints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // repeated .protocol.TMEndpoint endpoints = 2;
  inline int endpoints_size() const;
  inline void clear_endpoints();
  static const int kEndpointsFieldNumber = 2;
  inline const ::protocol::TMEndpoint& endpoints(int index) const;
  inline ::protocol::TMEndpoint* mutable_endpoints(int index);
  inline ::protocol::TMEndpoint* add_endpoints();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMEndpoint >&
      endpoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::TMEndpoint >*
      mutable_endpoints();

  // @@protoc_insertion_point(class_scope:protocol.TMEndpoints)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protocol::TMEndpoint > endpoints_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMEndpoints* default_instance_;
};
// -------------------------------------------------------------------

class TMIndexedObject : public ::google::protobuf::Message {
 public:
  TMIndexedObject();
  virtual ~TMIndexedObject();

  TMIndexedObject(const TMIndexedObject& from);

  inline TMIndexedObject& operator=(const TMIndexedObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMIndexedObject& default_instance();

  void Swap(TMIndexedObject* other);

  // implements Message ----------------------------------------------

  TMIndexedObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMIndexedObject& from);
  void MergeFrom(const TMIndexedObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // optional bytes nodeID = 2;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIDFieldNumber = 2;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const void* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  inline void set_allocated_nodeid(::std::string* nodeid);

  // optional bytes index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const void* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  inline void set_allocated_index(::std::string* index);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional uint32 ledgerSeq = 5;
  inline bool has_ledgerseq() const;
  inline void clear_ledgerseq();
  static const int kLedgerSeqFieldNumber = 5;
  inline ::google::protobuf::uint32 ledgerseq() const;
  inline void set_ledgerseq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMIndexedObject)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_ledgerseq();
  inline void clear_has_ledgerseq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hash_;
  ::std::string* nodeid_;
  ::std::string* index_;
  ::std::string* data_;
  ::google::protobuf::uint32 ledgerseq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMIndexedObject* default_instance_;
};
// -------------------------------------------------------------------

class TMGetObjectByHash : public ::google::protobuf::Message {
 public:
  TMGetObjectByHash();
  virtual ~TMGetObjectByHash();

  TMGetObjectByHash(const TMGetObjectByHash& from);

  inline TMGetObjectByHash& operator=(const TMGetObjectByHash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMGetObjectByHash& default_instance();

  void Swap(TMGetObjectByHash* other);

  // implements Message ----------------------------------------------

  TMGetObjectByHash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMGetObjectByHash& from);
  void MergeFrom(const TMGetObjectByHash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TMGetObjectByHash_ObjectType ObjectType;
  static const ObjectType otUNKNOWN = TMGetObjectByHash_ObjectType_otUNKNOWN;
  static const ObjectType otLEDGER = TMGetObjectByHash_ObjectType_otLEDGER;
  static const ObjectType otTRANSACTION = TMGetObjectByHash_ObjectType_otTRANSACTION;
  static const ObjectType otTRANSACTION_NODE = TMGetObjectByHash_ObjectType_otTRANSACTION_NODE;
  static const ObjectType otSTATE_NODE = TMGetObjectByHash_ObjectType_otSTATE_NODE;
  static const ObjectType otCAS_OBJECT = TMGetObjectByHash_ObjectType_otCAS_OBJECT;
  static const ObjectType otFETCH_PACK = TMGetObjectByHash_ObjectType_otFETCH_PACK;
  static inline bool ObjectType_IsValid(int value) {
    return TMGetObjectByHash_ObjectType_IsValid(value);
  }
  static const ObjectType ObjectType_MIN =
    TMGetObjectByHash_ObjectType_ObjectType_MIN;
  static const ObjectType ObjectType_MAX =
    TMGetObjectByHash_ObjectType_ObjectType_MAX;
  static const int ObjectType_ARRAYSIZE =
    TMGetObjectByHash_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectType_descriptor() {
    return TMGetObjectByHash_ObjectType_descriptor();
  }
  static inline const ::std::string& ObjectType_Name(ObjectType value) {
    return TMGetObjectByHash_ObjectType_Name(value);
  }
  static inline bool ObjectType_Parse(const ::std::string& name,
      ObjectType* value) {
    return TMGetObjectByHash_ObjectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::protocol::TMGetObjectByHash_ObjectType type() const;
  inline void set_type(::protocol::TMGetObjectByHash_ObjectType value);

  // required bool query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline bool query() const;
  inline void set_query(bool value);

  // optional uint32 seq = 3;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 3;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // optional bytes ledgerHash = 4;
  inline bool has_ledgerhash() const;
  inline void clear_ledgerhash();
  static const int kLedgerHashFieldNumber = 4;
  inline const ::std::string& ledgerhash() const;
  inline void set_ledgerhash(const ::std::string& value);
  inline void set_ledgerhash(const char* value);
  inline void set_ledgerhash(const void* value, size_t size);
  inline ::std::string* mutable_ledgerhash();
  inline ::std::string* release_ledgerhash();
  inline void set_allocated_ledgerhash(::std::string* ledgerhash);

  // optional bool fat = 5;
  inline bool has_fat() const;
  inline void clear_fat();
  static const int kFatFieldNumber = 5;
  inline bool fat() const;
  inline void set_fat(bool value);

  // repeated .protocol.TMIndexedObject objects = 6;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 6;
  inline const ::protocol::TMIndexedObject& objects(int index) const;
  inline ::protocol::TMIndexedObject* mutable_objects(int index);
  inline ::protocol::TMIndexedObject* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMIndexedObject >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::TMIndexedObject >*
      mutable_objects();

  // @@protoc_insertion_point(class_scope:protocol.TMGetObjectByHash)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_ledgerhash();
  inline void clear_has_ledgerhash();
  inline void set_has_fat();
  inline void clear_has_fat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 seq_;
  ::std::string* ledgerhash_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TMIndexedObject > objects_;
  bool query_;
  bool fat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMGetObjectByHash* default_instance_;
};
// -------------------------------------------------------------------

class TMLedgerNode : public ::google::protobuf::Message {
 public:
  TMLedgerNode();
  virtual ~TMLedgerNode();

  TMLedgerNode(const TMLedgerNode& from);

  inline TMLedgerNode& operator=(const TMLedgerNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMLedgerNode& default_instance();

  void Swap(TMLedgerNode* other);

  // implements Message ----------------------------------------------

  TMLedgerNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMLedgerNode& from);
  void MergeFrom(const TMLedgerNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes nodedata = 1;
  inline bool has_nodedata() const;
  inline void clear_nodedata();
  static const int kNodedataFieldNumber = 1;
  inline const ::std::string& nodedata() const;
  inline void set_nodedata(const ::std::string& value);
  inline void set_nodedata(const char* value);
  inline void set_nodedata(const void* value, size_t size);
  inline ::std::string* mutable_nodedata();
  inline ::std::string* release_nodedata();
  inline void set_allocated_nodedata(::std::string* nodedata);

  // optional bytes nodeid = 2;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeidFieldNumber = 2;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const void* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  inline void set_allocated_nodeid(::std::string* nodeid);

  // @@protoc_insertion_point(class_scope:protocol.TMLedgerNode)
 private:
  inline void set_has_nodedata();
  inline void clear_has_nodedata();
  inline void set_has_nodeid();
  inline void clear_has_nodeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nodedata_;
  ::std::string* nodeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMLedgerNode* default_instance_;
};
// -------------------------------------------------------------------

class TMGetLedger : public ::google::protobuf::Message {
 public:
  TMGetLedger();
  virtual ~TMGetLedger();

  TMGetLedger(const TMGetLedger& from);

  inline TMGetLedger& operator=(const TMGetLedger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMGetLedger& default_instance();

  void Swap(TMGetLedger* other);

  // implements Message ----------------------------------------------

  TMGetLedger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMGetLedger& from);
  void MergeFrom(const TMGetLedger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.TMLedgerInfoType itype = 1;
  inline bool has_itype() const;
  inline void clear_itype();
  static const int kItypeFieldNumber = 1;
  inline ::protocol::TMLedgerInfoType itype() const;
  inline void set_itype(::protocol::TMLedgerInfoType value);

  // optional .protocol.TMLedgerType ltype = 2;
  inline bool has_ltype() const;
  inline void clear_ltype();
  static const int kLtypeFieldNumber = 2;
  inline ::protocol::TMLedgerType ltype() const;
  inline void set_ltype(::protocol::TMLedgerType value);

  // optional bytes ledgerHash = 3;
  inline bool has_ledgerhash() const;
  inline void clear_ledgerhash();
  static const int kLedgerHashFieldNumber = 3;
  inline const ::std::string& ledgerhash() const;
  inline void set_ledgerhash(const ::std::string& value);
  inline void set_ledgerhash(const char* value);
  inline void set_ledgerhash(const void* value, size_t size);
  inline ::std::string* mutable_ledgerhash();
  inline ::std::string* release_ledgerhash();
  inline void set_allocated_ledgerhash(::std::string* ledgerhash);

  // optional uint32 ledgerSeq = 4;
  inline bool has_ledgerseq() const;
  inline void clear_ledgerseq();
  static const int kLedgerSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 ledgerseq() const;
  inline void set_ledgerseq(::google::protobuf::uint32 value);

  // repeated bytes nodeIDs = 5;
  inline int nodeids_size() const;
  inline void clear_nodeids();
  static const int kNodeIDsFieldNumber = 5;
  inline const ::std::string& nodeids(int index) const;
  inline ::std::string* mutable_nodeids(int index);
  inline void set_nodeids(int index, const ::std::string& value);
  inline void set_nodeids(int index, const char* value);
  inline void set_nodeids(int index, const void* value, size_t size);
  inline ::std::string* add_nodeids();
  inline void add_nodeids(const ::std::string& value);
  inline void add_nodeids(const char* value);
  inline void add_nodeids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nodeids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodeids();

  // optional uint64 requestCookie = 6;
  inline bool has_requestcookie() const;
  inline void clear_requestcookie();
  static const int kRequestCookieFieldNumber = 6;
  inline ::google::protobuf::uint64 requestcookie() const;
  inline void set_requestcookie(::google::protobuf::uint64 value);

  // optional .protocol.TMQueryType queryType = 7;
  inline bool has_querytype() const;
  inline void clear_querytype();
  static const int kQueryTypeFieldNumber = 7;
  inline ::protocol::TMQueryType querytype() const;
  inline void set_querytype(::protocol::TMQueryType value);

  // optional uint32 queryDepth = 8;
  inline bool has_querydepth() const;
  inline void clear_querydepth();
  static const int kQueryDepthFieldNumber = 8;
  inline ::google::protobuf::uint32 querydepth() const;
  inline void set_querydepth(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.TMGetLedger)
 private:
  inline void set_has_itype();
  inline void clear_has_itype();
  inline void set_has_ltype();
  inline void clear_has_ltype();
  inline void set_has_ledgerhash();
  inline void clear_has_ledgerhash();
  inline void set_has_ledgerseq();
  inline void clear_has_ledgerseq();
  inline void set_has_requestcookie();
  inline void clear_has_requestcookie();
  inline void set_has_querytype();
  inline void clear_has_querytype();
  inline void set_has_querydepth();
  inline void clear_has_querydepth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int itype_;
  int ltype_;
  ::std::string* ledgerhash_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nodeids_;
  ::google::protobuf::uint32 ledgerseq_;
  int querytype_;
  ::google::protobuf::uint64 requestcookie_;
  ::google::protobuf::uint32 querydepth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMGetLedger* default_instance_;
};
// -------------------------------------------------------------------

class TMLedgerData : public ::google::protobuf::Message {
 public:
  TMLedgerData();
  virtual ~TMLedgerData();

  TMLedgerData(const TMLedgerData& from);

  inline TMLedgerData& operator=(const TMLedgerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMLedgerData& default_instance();

  void Swap(TMLedgerData* other);

  // implements Message ----------------------------------------------

  TMLedgerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMLedgerData& from);
  void MergeFrom(const TMLedgerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ledgerHash = 1;
  inline bool has_ledgerhash() const;
  inline void clear_ledgerhash();
  static const int kLedgerHashFieldNumber = 1;
  inline const ::std::string& ledgerhash() const;
  inline void set_ledgerhash(const ::std::string& value);
  inline void set_ledgerhash(const char* value);
  inline void set_ledgerhash(const void* value, size_t size);
  inline ::std::string* mutable_ledgerhash();
  inline ::std::string* release_ledgerhash();
  inline void set_allocated_ledgerhash(::std::string* ledgerhash);

  // required uint32 ledgerSeq = 2;
  inline bool has_ledgerseq() const;
  inline void clear_ledgerseq();
  static const int kLedgerSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 ledgerseq() const;
  inline void set_ledgerseq(::google::protobuf::uint32 value);

  // required .protocol.TMLedgerInfoType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::protocol::TMLedgerInfoType type() const;
  inline void set_type(::protocol::TMLedgerInfoType value);

  // repeated .protocol.TMLedgerNode nodes = 4;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 4;
  inline const ::protocol::TMLedgerNode& nodes(int index) const;
  inline ::protocol::TMLedgerNode* mutable_nodes(int index);
  inline ::protocol::TMLedgerNode* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMLedgerNode >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::TMLedgerNode >*
      mutable_nodes();

  // optional uint32 requestCookie = 5;
  inline bool has_requestcookie() const;
  inline void clear_requestcookie();
  static const int kRequestCookieFieldNumber = 5;
  inline ::google::protobuf::uint32 requestcookie() const;
  inline void set_requestcookie(::google::protobuf::uint32 value);

  // optional .protocol.TMReplyError error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline ::protocol::TMReplyError error() const;
  inline void set_error(::protocol::TMReplyError value);

  // @@protoc_insertion_point(class_scope:protocol.TMLedgerData)
 private:
  inline void set_has_ledgerhash();
  inline void clear_has_ledgerhash();
  inline void set_has_ledgerseq();
  inline void clear_has_ledgerseq();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_requestcookie();
  inline void clear_has_requestcookie();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ledgerhash_;
  ::google::protobuf::uint32 ledgerseq_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TMLedgerNode > nodes_;
  ::google::protobuf::uint32 requestcookie_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMLedgerData* default_instance_;
};
// -------------------------------------------------------------------

class TMPing : public ::google::protobuf::Message {
 public:
  TMPing();
  virtual ~TMPing();

  TMPing(const TMPing& from);

  inline TMPing& operator=(const TMPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TMPing& default_instance();

  void Swap(TMPing* other);

  // implements Message ----------------------------------------------

  TMPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TMPing& from);
  void MergeFrom(const TMPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TMPing_pingType pingType;
  static const pingType ptPING = TMPing_pingType_ptPING;
  static const pingType ptPONG = TMPing_pingType_ptPONG;
  static inline bool pingType_IsValid(int value) {
    return TMPing_pingType_IsValid(value);
  }
  static const pingType pingType_MIN =
    TMPing_pingType_pingType_MIN;
  static const pingType pingType_MAX =
    TMPing_pingType_pingType_MAX;
  static const int pingType_ARRAYSIZE =
    TMPing_pingType_pingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  pingType_descriptor() {
    return TMPing_pingType_descriptor();
  }
  static inline const ::std::string& pingType_Name(pingType value) {
    return TMPing_pingType_Name(value);
  }
  static inline bool pingType_Parse(const ::std::string& name,
      pingType* value) {
    return TMPing_pingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protocol.TMPing.pingType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::protocol::TMPing_pingType type() const;
  inline void set_type(::protocol::TMPing_pingType value);

  // optional uint32 seq = 2;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 2;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // optional uint64 pingTime = 3;
  inline bool has_pingtime() const;
  inline void clear_pingtime();
  static const int kPingTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 pingtime() const;
  inline void set_pingtime(::google::protobuf::uint64 value);

  // optional uint64 netTime = 4;
  inline bool has_nettime() const;
  inline void clear_nettime();
  static const int kNetTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 nettime() const;
  inline void set_nettime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.TMPing)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_pingtime();
  inline void clear_has_pingtime();
  inline void set_has_nettime();
  inline void clear_has_nettime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 seq_;
  ::google::protobuf::uint64 pingtime_;
  ::google::protobuf::uint64 nettime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_skywell_2eproto();
  friend void protobuf_AssignDesc_skywell_2eproto();
  friend void protobuf_ShutdownFile_skywell_2eproto();

  void InitAsDefaultInstance();
  static TMPing* default_instance_;
};
// ===================================================================


// ===================================================================

// TMProofWork

// required string token = 1;
inline bool TMProofWork::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMProofWork::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMProofWork::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMProofWork::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& TMProofWork::token() const {
  return *token_;
}
inline void TMProofWork::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TMProofWork::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TMProofWork::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProofWork::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* TMProofWork::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProofWork::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 iterations = 2;
inline bool TMProofWork::has_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMProofWork::set_has_iterations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMProofWork::clear_has_iterations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMProofWork::clear_iterations() {
  iterations_ = 0u;
  clear_has_iterations();
}
inline ::google::protobuf::uint32 TMProofWork::iterations() const {
  return iterations_;
}
inline void TMProofWork::set_iterations(::google::protobuf::uint32 value) {
  set_has_iterations();
  iterations_ = value;
}

// optional bytes target = 3;
inline bool TMProofWork::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMProofWork::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMProofWork::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMProofWork::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& TMProofWork::target() const {
  return *target_;
}
inline void TMProofWork::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TMProofWork::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TMProofWork::set_target(const void* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProofWork::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* TMProofWork::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProofWork::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes challenge = 4;
inline bool TMProofWork::has_challenge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMProofWork::set_has_challenge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMProofWork::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMProofWork::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& TMProofWork::challenge() const {
  return *challenge_;
}
inline void TMProofWork::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void TMProofWork::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void TMProofWork::set_challenge(const void* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProofWork::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  return challenge_;
}
inline ::std::string* TMProofWork::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProofWork::set_allocated_challenge(::std::string* challenge) {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  if (challenge) {
    set_has_challenge();
    challenge_ = challenge;
  } else {
    clear_has_challenge();
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes response = 5;
inline bool TMProofWork::has_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMProofWork::set_has_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMProofWork::clear_has_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMProofWork::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& TMProofWork::response() const {
  return *response_;
}
inline void TMProofWork::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void TMProofWork::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void TMProofWork::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProofWork::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* TMProofWork::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProofWork::set_allocated_response(::std::string* response) {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    delete response_;
  }
  if (response) {
    set_has_response();
    response_ = response;
  } else {
    clear_has_response();
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocol.TMProofWork.PowResult result = 6;
inline bool TMProofWork::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMProofWork::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMProofWork::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMProofWork::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::protocol::TMProofWork_PowResult TMProofWork::result() const {
  return static_cast< ::protocol::TMProofWork_PowResult >(result_);
}
inline void TMProofWork::set_result(::protocol::TMProofWork_PowResult value) {
  assert(::protocol::TMProofWork_PowResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// TMHello

// required uint32 protoVersion = 1;
inline bool TMHello::has_protoversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMHello::set_has_protoversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMHello::clear_has_protoversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMHello::clear_protoversion() {
  protoversion_ = 0u;
  clear_has_protoversion();
}
inline ::google::protobuf::uint32 TMHello::protoversion() const {
  return protoversion_;
}
inline void TMHello::set_protoversion(::google::protobuf::uint32 value) {
  set_has_protoversion();
  protoversion_ = value;
}

// required uint32 protoVersionMin = 2;
inline bool TMHello::has_protoversionmin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMHello::set_has_protoversionmin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMHello::clear_has_protoversionmin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMHello::clear_protoversionmin() {
  protoversionmin_ = 0u;
  clear_has_protoversionmin();
}
inline ::google::protobuf::uint32 TMHello::protoversionmin() const {
  return protoversionmin_;
}
inline void TMHello::set_protoversionmin(::google::protobuf::uint32 value) {
  set_has_protoversionmin();
  protoversionmin_ = value;
}

// required bytes nodePublic = 3;
inline bool TMHello::has_nodepublic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMHello::set_has_nodepublic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMHello::clear_has_nodepublic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMHello::clear_nodepublic() {
  if (nodepublic_ != &::google::protobuf::internal::kEmptyString) {
    nodepublic_->clear();
  }
  clear_has_nodepublic();
}
inline const ::std::string& TMHello::nodepublic() const {
  return *nodepublic_;
}
inline void TMHello::set_nodepublic(const ::std::string& value) {
  set_has_nodepublic();
  if (nodepublic_ == &::google::protobuf::internal::kEmptyString) {
    nodepublic_ = new ::std::string;
  }
  nodepublic_->assign(value);
}
inline void TMHello::set_nodepublic(const char* value) {
  set_has_nodepublic();
  if (nodepublic_ == &::google::protobuf::internal::kEmptyString) {
    nodepublic_ = new ::std::string;
  }
  nodepublic_->assign(value);
}
inline void TMHello::set_nodepublic(const void* value, size_t size) {
  set_has_nodepublic();
  if (nodepublic_ == &::google::protobuf::internal::kEmptyString) {
    nodepublic_ = new ::std::string;
  }
  nodepublic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMHello::mutable_nodepublic() {
  set_has_nodepublic();
  if (nodepublic_ == &::google::protobuf::internal::kEmptyString) {
    nodepublic_ = new ::std::string;
  }
  return nodepublic_;
}
inline ::std::string* TMHello::release_nodepublic() {
  clear_has_nodepublic();
  if (nodepublic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodepublic_;
    nodepublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMHello::set_allocated_nodepublic(::std::string* nodepublic) {
  if (nodepublic_ != &::google::protobuf::internal::kEmptyString) {
    delete nodepublic_;
  }
  if (nodepublic) {
    set_has_nodepublic();
    nodepublic_ = nodepublic;
  } else {
    clear_has_nodepublic();
    nodepublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes nodeProof = 4;
inline bool TMHello::has_nodeproof() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMHello::set_has_nodeproof() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMHello::clear_has_nodeproof() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMHello::clear_nodeproof() {
  if (nodeproof_ != &::google::protobuf::internal::kEmptyString) {
    nodeproof_->clear();
  }
  clear_has_nodeproof();
}
inline const ::std::string& TMHello::nodeproof() const {
  return *nodeproof_;
}
inline void TMHello::set_nodeproof(const ::std::string& value) {
  set_has_nodeproof();
  if (nodeproof_ == &::google::protobuf::internal::kEmptyString) {
    nodeproof_ = new ::std::string;
  }
  nodeproof_->assign(value);
}
inline void TMHello::set_nodeproof(const char* value) {
  set_has_nodeproof();
  if (nodeproof_ == &::google::protobuf::internal::kEmptyString) {
    nodeproof_ = new ::std::string;
  }
  nodeproof_->assign(value);
}
inline void TMHello::set_nodeproof(const void* value, size_t size) {
  set_has_nodeproof();
  if (nodeproof_ == &::google::protobuf::internal::kEmptyString) {
    nodeproof_ = new ::std::string;
  }
  nodeproof_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMHello::mutable_nodeproof() {
  set_has_nodeproof();
  if (nodeproof_ == &::google::protobuf::internal::kEmptyString) {
    nodeproof_ = new ::std::string;
  }
  return nodeproof_;
}
inline ::std::string* TMHello::release_nodeproof() {
  clear_has_nodeproof();
  if (nodeproof_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeproof_;
    nodeproof_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMHello::set_allocated_nodeproof(::std::string* nodeproof) {
  if (nodeproof_ != &::google::protobuf::internal::kEmptyString) {
    delete nodeproof_;
  }
  if (nodeproof) {
    set_has_nodeproof();
    nodeproof_ = nodeproof;
  } else {
    clear_has_nodeproof();
    nodeproof_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fullVersion = 5;
inline bool TMHello::has_fullversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMHello::set_has_fullversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMHello::clear_has_fullversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMHello::clear_fullversion() {
  if (fullversion_ != &::google::protobuf::internal::kEmptyString) {
    fullversion_->clear();
  }
  clear_has_fullversion();
}
inline const ::std::string& TMHello::fullversion() const {
  return *fullversion_;
}
inline void TMHello::set_fullversion(const ::std::string& value) {
  set_has_fullversion();
  if (fullversion_ == &::google::protobuf::internal::kEmptyString) {
    fullversion_ = new ::std::string;
  }
  fullversion_->assign(value);
}
inline void TMHello::set_fullversion(const char* value) {
  set_has_fullversion();
  if (fullversion_ == &::google::protobuf::internal::kEmptyString) {
    fullversion_ = new ::std::string;
  }
  fullversion_->assign(value);
}
inline void TMHello::set_fullversion(const char* value, size_t size) {
  set_has_fullversion();
  if (fullversion_ == &::google::protobuf::internal::kEmptyString) {
    fullversion_ = new ::std::string;
  }
  fullversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMHello::mutable_fullversion() {
  set_has_fullversion();
  if (fullversion_ == &::google::protobuf::internal::kEmptyString) {
    fullversion_ = new ::std::string;
  }
  return fullversion_;
}
inline ::std::string* TMHello::release_fullversion() {
  clear_has_fullversion();
  if (fullversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fullversion_;
    fullversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMHello::set_allocated_fullversion(::std::string* fullversion) {
  if (fullversion_ != &::google::protobuf::internal::kEmptyString) {
    delete fullversion_;
  }
  if (fullversion) {
    set_has_fullversion();
    fullversion_ = fullversion;
  } else {
    clear_has_fullversion();
    fullversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 netTime = 6;
inline bool TMHello::has_nettime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMHello::set_has_nettime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMHello::clear_has_nettime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMHello::clear_nettime() {
  nettime_ = GOOGLE_ULONGLONG(0);
  clear_has_nettime();
}
inline ::google::protobuf::uint64 TMHello::nettime() const {
  return nettime_;
}
inline void TMHello::set_nettime(::google::protobuf::uint64 value) {
  set_has_nettime();
  nettime_ = value;
}

// optional uint32 ipv4Port = 7;
inline bool TMHello::has_ipv4port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMHello::set_has_ipv4port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMHello::clear_has_ipv4port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMHello::clear_ipv4port() {
  ipv4port_ = 0u;
  clear_has_ipv4port();
}
inline ::google::protobuf::uint32 TMHello::ipv4port() const {
  return ipv4port_;
}
inline void TMHello::set_ipv4port(::google::protobuf::uint32 value) {
  set_has_ipv4port();
  ipv4port_ = value;
}

// optional uint32 ledgerIndex = 8;
inline bool TMHello::has_ledgerindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMHello::set_has_ledgerindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMHello::clear_has_ledgerindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMHello::clear_ledgerindex() {
  ledgerindex_ = 0u;
  clear_has_ledgerindex();
}
inline ::google::protobuf::uint32 TMHello::ledgerindex() const {
  return ledgerindex_;
}
inline void TMHello::set_ledgerindex(::google::protobuf::uint32 value) {
  set_has_ledgerindex();
  ledgerindex_ = value;
}

// optional bytes ledgerClosed = 9;
inline bool TMHello::has_ledgerclosed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TMHello::set_has_ledgerclosed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TMHello::clear_has_ledgerclosed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TMHello::clear_ledgerclosed() {
  if (ledgerclosed_ != &::google::protobuf::internal::kEmptyString) {
    ledgerclosed_->clear();
  }
  clear_has_ledgerclosed();
}
inline const ::std::string& TMHello::ledgerclosed() const {
  return *ledgerclosed_;
}
inline void TMHello::set_ledgerclosed(const ::std::string& value) {
  set_has_ledgerclosed();
  if (ledgerclosed_ == &::google::protobuf::internal::kEmptyString) {
    ledgerclosed_ = new ::std::string;
  }
  ledgerclosed_->assign(value);
}
inline void TMHello::set_ledgerclosed(const char* value) {
  set_has_ledgerclosed();
  if (ledgerclosed_ == &::google::protobuf::internal::kEmptyString) {
    ledgerclosed_ = new ::std::string;
  }
  ledgerclosed_->assign(value);
}
inline void TMHello::set_ledgerclosed(const void* value, size_t size) {
  set_has_ledgerclosed();
  if (ledgerclosed_ == &::google::protobuf::internal::kEmptyString) {
    ledgerclosed_ = new ::std::string;
  }
  ledgerclosed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMHello::mutable_ledgerclosed() {
  set_has_ledgerclosed();
  if (ledgerclosed_ == &::google::protobuf::internal::kEmptyString) {
    ledgerclosed_ = new ::std::string;
  }
  return ledgerclosed_;
}
inline ::std::string* TMHello::release_ledgerclosed() {
  clear_has_ledgerclosed();
  if (ledgerclosed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerclosed_;
    ledgerclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMHello::set_allocated_ledgerclosed(::std::string* ledgerclosed) {
  if (ledgerclosed_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerclosed_;
  }
  if (ledgerclosed) {
    set_has_ledgerclosed();
    ledgerclosed_ = ledgerclosed;
  } else {
    clear_has_ledgerclosed();
    ledgerclosed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ledgerPrevious = 10;
inline bool TMHello::has_ledgerprevious() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMHello::set_has_ledgerprevious() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMHello::clear_has_ledgerprevious() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMHello::clear_ledgerprevious() {
  if (ledgerprevious_ != &::google::protobuf::internal::kEmptyString) {
    ledgerprevious_->clear();
  }
  clear_has_ledgerprevious();
}
inline const ::std::string& TMHello::ledgerprevious() const {
  return *ledgerprevious_;
}
inline void TMHello::set_ledgerprevious(const ::std::string& value) {
  set_has_ledgerprevious();
  if (ledgerprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerprevious_ = new ::std::string;
  }
  ledgerprevious_->assign(value);
}
inline void TMHello::set_ledgerprevious(const char* value) {
  set_has_ledgerprevious();
  if (ledgerprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerprevious_ = new ::std::string;
  }
  ledgerprevious_->assign(value);
}
inline void TMHello::set_ledgerprevious(const void* value, size_t size) {
  set_has_ledgerprevious();
  if (ledgerprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerprevious_ = new ::std::string;
  }
  ledgerprevious_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMHello::mutable_ledgerprevious() {
  set_has_ledgerprevious();
  if (ledgerprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerprevious_ = new ::std::string;
  }
  return ledgerprevious_;
}
inline ::std::string* TMHello::release_ledgerprevious() {
  clear_has_ledgerprevious();
  if (ledgerprevious_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerprevious_;
    ledgerprevious_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMHello::set_allocated_ledgerprevious(::std::string* ledgerprevious) {
  if (ledgerprevious_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerprevious_;
  }
  if (ledgerprevious) {
    set_has_ledgerprevious();
    ledgerprevious_ = ledgerprevious;
  } else {
    clear_has_ledgerprevious();
    ledgerprevious_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool nodePrivate = 11;
inline bool TMHello::has_nodeprivate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TMHello::set_has_nodeprivate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TMHello::clear_has_nodeprivate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TMHello::clear_nodeprivate() {
  nodeprivate_ = false;
  clear_has_nodeprivate();
}
inline bool TMHello::nodeprivate() const {
  return nodeprivate_;
}
inline void TMHello::set_nodeprivate(bool value) {
  set_has_nodeprivate();
  nodeprivate_ = value;
}

// optional .protocol.TMProofWork proofOfWork = 12;
inline bool TMHello::has_proofofwork() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TMHello::set_has_proofofwork() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TMHello::clear_has_proofofwork() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TMHello::clear_proofofwork() {
  if (proofofwork_ != NULL) proofofwork_->::protocol::TMProofWork::Clear();
  clear_has_proofofwork();
}
inline const ::protocol::TMProofWork& TMHello::proofofwork() const {
  return proofofwork_ != NULL ? *proofofwork_ : *default_instance_->proofofwork_;
}
inline ::protocol::TMProofWork* TMHello::mutable_proofofwork() {
  set_has_proofofwork();
  if (proofofwork_ == NULL) proofofwork_ = new ::protocol::TMProofWork;
  return proofofwork_;
}
inline ::protocol::TMProofWork* TMHello::release_proofofwork() {
  clear_has_proofofwork();
  ::protocol::TMProofWork* temp = proofofwork_;
  proofofwork_ = NULL;
  return temp;
}
inline void TMHello::set_allocated_proofofwork(::protocol::TMProofWork* proofofwork) {
  delete proofofwork_;
  proofofwork_ = proofofwork;
  if (proofofwork) {
    set_has_proofofwork();
  } else {
    clear_has_proofofwork();
  }
}

// optional bool testNet = 13;
inline bool TMHello::has_testnet() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TMHello::set_has_testnet() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TMHello::clear_has_testnet() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TMHello::clear_testnet() {
  testnet_ = false;
  clear_has_testnet();
}
inline bool TMHello::testnet() const {
  return testnet_;
}
inline void TMHello::set_testnet(bool value) {
  set_has_testnet();
  testnet_ = value;
}

// -------------------------------------------------------------------

// TMClusterNode

// required string publicKey = 1;
inline bool TMClusterNode::has_publickey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMClusterNode::set_has_publickey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMClusterNode::clear_has_publickey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMClusterNode::clear_publickey() {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    publickey_->clear();
  }
  clear_has_publickey();
}
inline const ::std::string& TMClusterNode::publickey() const {
  return *publickey_;
}
inline void TMClusterNode::set_publickey(const ::std::string& value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void TMClusterNode::set_publickey(const char* value) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(value);
}
inline void TMClusterNode::set_publickey(const char* value, size_t size) {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  publickey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMClusterNode::mutable_publickey() {
  set_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    publickey_ = new ::std::string;
  }
  return publickey_;
}
inline ::std::string* TMClusterNode::release_publickey() {
  clear_has_publickey();
  if (publickey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickey_;
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMClusterNode::set_allocated_publickey(::std::string* publickey) {
  if (publickey_ != &::google::protobuf::internal::kEmptyString) {
    delete publickey_;
  }
  if (publickey) {
    set_has_publickey();
    publickey_ = publickey;
  } else {
    clear_has_publickey();
    publickey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 reportTime = 2;
inline bool TMClusterNode::has_reporttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMClusterNode::set_has_reporttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMClusterNode::clear_has_reporttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMClusterNode::clear_reporttime() {
  reporttime_ = 0u;
  clear_has_reporttime();
}
inline ::google::protobuf::uint32 TMClusterNode::reporttime() const {
  return reporttime_;
}
inline void TMClusterNode::set_reporttime(::google::protobuf::uint32 value) {
  set_has_reporttime();
  reporttime_ = value;
}

// required uint32 nodeLoad = 3;
inline bool TMClusterNode::has_nodeload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMClusterNode::set_has_nodeload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMClusterNode::clear_has_nodeload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMClusterNode::clear_nodeload() {
  nodeload_ = 0u;
  clear_has_nodeload();
}
inline ::google::protobuf::uint32 TMClusterNode::nodeload() const {
  return nodeload_;
}
inline void TMClusterNode::set_nodeload(::google::protobuf::uint32 value) {
  set_has_nodeload();
  nodeload_ = value;
}

// optional string nodeName = 4;
inline bool TMClusterNode::has_nodename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMClusterNode::set_has_nodename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMClusterNode::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMClusterNode::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& TMClusterNode::nodename() const {
  return *nodename_;
}
inline void TMClusterNode::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void TMClusterNode::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void TMClusterNode::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMClusterNode::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  return nodename_;
}
inline ::std::string* TMClusterNode::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMClusterNode::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool TMClusterNode::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMClusterNode::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMClusterNode::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMClusterNode::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& TMClusterNode::address() const {
  return *address_;
}
inline void TMClusterNode::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TMClusterNode::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TMClusterNode::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMClusterNode::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* TMClusterNode::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMClusterNode::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMLoadSource

// required string name = 1;
inline bool TMLoadSource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMLoadSource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMLoadSource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMLoadSource::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TMLoadSource::name() const {
  return *name_;
}
inline void TMLoadSource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMLoadSource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TMLoadSource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMLoadSource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TMLoadSource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMLoadSource::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 cost = 2;
inline bool TMLoadSource::has_cost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMLoadSource::set_has_cost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMLoadSource::clear_has_cost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMLoadSource::clear_cost() {
  cost_ = 0u;
  clear_has_cost();
}
inline ::google::protobuf::uint32 TMLoadSource::cost() const {
  return cost_;
}
inline void TMLoadSource::set_cost(::google::protobuf::uint32 value) {
  set_has_cost();
  cost_ = value;
}

// optional uint32 count = 3;
inline bool TMLoadSource::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMLoadSource::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMLoadSource::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMLoadSource::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 TMLoadSource::count() const {
  return count_;
}
inline void TMLoadSource::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// TMCluster

// repeated .protocol.TMClusterNode clusterNodes = 1;
inline int TMCluster::clusternodes_size() const {
  return clusternodes_.size();
}
inline void TMCluster::clear_clusternodes() {
  clusternodes_.Clear();
}
inline const ::protocol::TMClusterNode& TMCluster::clusternodes(int index) const {
  return clusternodes_.Get(index);
}
inline ::protocol::TMClusterNode* TMCluster::mutable_clusternodes(int index) {
  return clusternodes_.Mutable(index);
}
inline ::protocol::TMClusterNode* TMCluster::add_clusternodes() {
  return clusternodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMClusterNode >&
TMCluster::clusternodes() const {
  return clusternodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TMClusterNode >*
TMCluster::mutable_clusternodes() {
  return &clusternodes_;
}

// repeated .protocol.TMLoadSource loadSources = 2;
inline int TMCluster::loadsources_size() const {
  return loadsources_.size();
}
inline void TMCluster::clear_loadsources() {
  loadsources_.Clear();
}
inline const ::protocol::TMLoadSource& TMCluster::loadsources(int index) const {
  return loadsources_.Get(index);
}
inline ::protocol::TMLoadSource* TMCluster::mutable_loadsources(int index) {
  return loadsources_.Mutable(index);
}
inline ::protocol::TMLoadSource* TMCluster::add_loadsources() {
  return loadsources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMLoadSource >&
TMCluster::loadsources() const {
  return loadsources_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TMLoadSource >*
TMCluster::mutable_loadsources() {
  return &loadsources_;
}

// -------------------------------------------------------------------

// TMTransaction

// required bytes rawTransaction = 1;
inline bool TMTransaction::has_rawtransaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMTransaction::set_has_rawtransaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMTransaction::clear_has_rawtransaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMTransaction::clear_rawtransaction() {
  if (rawtransaction_ != &::google::protobuf::internal::kEmptyString) {
    rawtransaction_->clear();
  }
  clear_has_rawtransaction();
}
inline const ::std::string& TMTransaction::rawtransaction() const {
  return *rawtransaction_;
}
inline void TMTransaction::set_rawtransaction(const ::std::string& value) {
  set_has_rawtransaction();
  if (rawtransaction_ == &::google::protobuf::internal::kEmptyString) {
    rawtransaction_ = new ::std::string;
  }
  rawtransaction_->assign(value);
}
inline void TMTransaction::set_rawtransaction(const char* value) {
  set_has_rawtransaction();
  if (rawtransaction_ == &::google::protobuf::internal::kEmptyString) {
    rawtransaction_ = new ::std::string;
  }
  rawtransaction_->assign(value);
}
inline void TMTransaction::set_rawtransaction(const void* value, size_t size) {
  set_has_rawtransaction();
  if (rawtransaction_ == &::google::protobuf::internal::kEmptyString) {
    rawtransaction_ = new ::std::string;
  }
  rawtransaction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMTransaction::mutable_rawtransaction() {
  set_has_rawtransaction();
  if (rawtransaction_ == &::google::protobuf::internal::kEmptyString) {
    rawtransaction_ = new ::std::string;
  }
  return rawtransaction_;
}
inline ::std::string* TMTransaction::release_rawtransaction() {
  clear_has_rawtransaction();
  if (rawtransaction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rawtransaction_;
    rawtransaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMTransaction::set_allocated_rawtransaction(::std::string* rawtransaction) {
  if (rawtransaction_ != &::google::protobuf::internal::kEmptyString) {
    delete rawtransaction_;
  }
  if (rawtransaction) {
    set_has_rawtransaction();
    rawtransaction_ = rawtransaction;
  } else {
    clear_has_rawtransaction();
    rawtransaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .protocol.TransactionStatus status = 2;
inline bool TMTransaction::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMTransaction::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMTransaction::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMTransaction::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::protocol::TransactionStatus TMTransaction::status() const {
  return static_cast< ::protocol::TransactionStatus >(status_);
}
inline void TMTransaction::set_status(::protocol::TransactionStatus value) {
  assert(::protocol::TransactionStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional uint64 receiveTimestamp = 3;
inline bool TMTransaction::has_receivetimestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMTransaction::set_has_receivetimestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMTransaction::clear_has_receivetimestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMTransaction::clear_receivetimestamp() {
  receivetimestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_receivetimestamp();
}
inline ::google::protobuf::uint64 TMTransaction::receivetimestamp() const {
  return receivetimestamp_;
}
inline void TMTransaction::set_receivetimestamp(::google::protobuf::uint64 value) {
  set_has_receivetimestamp();
  receivetimestamp_ = value;
}

// optional bool deferred = 4;
inline bool TMTransaction::has_deferred() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMTransaction::set_has_deferred() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMTransaction::clear_has_deferred() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMTransaction::clear_deferred() {
  deferred_ = false;
  clear_has_deferred();
}
inline bool TMTransaction::deferred() const {
  return deferred_;
}
inline void TMTransaction::set_deferred(bool value) {
  set_has_deferred();
  deferred_ = value;
}

// -------------------------------------------------------------------

// TMStatusChange

// optional .protocol.NodeStatus newStatus = 1;
inline bool TMStatusChange::has_newstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMStatusChange::set_has_newstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMStatusChange::clear_has_newstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMStatusChange::clear_newstatus() {
  newstatus_ = 1;
  clear_has_newstatus();
}
inline ::protocol::NodeStatus TMStatusChange::newstatus() const {
  return static_cast< ::protocol::NodeStatus >(newstatus_);
}
inline void TMStatusChange::set_newstatus(::protocol::NodeStatus value) {
  assert(::protocol::NodeStatus_IsValid(value));
  set_has_newstatus();
  newstatus_ = value;
}

// optional .protocol.NodeEvent newEvent = 2;
inline bool TMStatusChange::has_newevent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMStatusChange::set_has_newevent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMStatusChange::clear_has_newevent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMStatusChange::clear_newevent() {
  newevent_ = 1;
  clear_has_newevent();
}
inline ::protocol::NodeEvent TMStatusChange::newevent() const {
  return static_cast< ::protocol::NodeEvent >(newevent_);
}
inline void TMStatusChange::set_newevent(::protocol::NodeEvent value) {
  assert(::protocol::NodeEvent_IsValid(value));
  set_has_newevent();
  newevent_ = value;
}

// optional uint32 ledgerSeq = 3;
inline bool TMStatusChange::has_ledgerseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMStatusChange::set_has_ledgerseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMStatusChange::clear_has_ledgerseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMStatusChange::clear_ledgerseq() {
  ledgerseq_ = 0u;
  clear_has_ledgerseq();
}
inline ::google::protobuf::uint32 TMStatusChange::ledgerseq() const {
  return ledgerseq_;
}
inline void TMStatusChange::set_ledgerseq(::google::protobuf::uint32 value) {
  set_has_ledgerseq();
  ledgerseq_ = value;
}

// optional bytes ledgerHash = 4;
inline bool TMStatusChange::has_ledgerhash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMStatusChange::set_has_ledgerhash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMStatusChange::clear_has_ledgerhash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMStatusChange::clear_ledgerhash() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    ledgerhash_->clear();
  }
  clear_has_ledgerhash();
}
inline const ::std::string& TMStatusChange::ledgerhash() const {
  return *ledgerhash_;
}
inline void TMStatusChange::set_ledgerhash(const ::std::string& value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMStatusChange::set_ledgerhash(const char* value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMStatusChange::set_ledgerhash(const void* value, size_t size) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMStatusChange::mutable_ledgerhash() {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  return ledgerhash_;
}
inline ::std::string* TMStatusChange::release_ledgerhash() {
  clear_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerhash_;
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMStatusChange::set_allocated_ledgerhash(::std::string* ledgerhash) {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (ledgerhash) {
    set_has_ledgerhash();
    ledgerhash_ = ledgerhash;
  } else {
    clear_has_ledgerhash();
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ledgerHashPrevious = 5;
inline bool TMStatusChange::has_ledgerhashprevious() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMStatusChange::set_has_ledgerhashprevious() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMStatusChange::clear_has_ledgerhashprevious() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMStatusChange::clear_ledgerhashprevious() {
  if (ledgerhashprevious_ != &::google::protobuf::internal::kEmptyString) {
    ledgerhashprevious_->clear();
  }
  clear_has_ledgerhashprevious();
}
inline const ::std::string& TMStatusChange::ledgerhashprevious() const {
  return *ledgerhashprevious_;
}
inline void TMStatusChange::set_ledgerhashprevious(const ::std::string& value) {
  set_has_ledgerhashprevious();
  if (ledgerhashprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhashprevious_ = new ::std::string;
  }
  ledgerhashprevious_->assign(value);
}
inline void TMStatusChange::set_ledgerhashprevious(const char* value) {
  set_has_ledgerhashprevious();
  if (ledgerhashprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhashprevious_ = new ::std::string;
  }
  ledgerhashprevious_->assign(value);
}
inline void TMStatusChange::set_ledgerhashprevious(const void* value, size_t size) {
  set_has_ledgerhashprevious();
  if (ledgerhashprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhashprevious_ = new ::std::string;
  }
  ledgerhashprevious_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMStatusChange::mutable_ledgerhashprevious() {
  set_has_ledgerhashprevious();
  if (ledgerhashprevious_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhashprevious_ = new ::std::string;
  }
  return ledgerhashprevious_;
}
inline ::std::string* TMStatusChange::release_ledgerhashprevious() {
  clear_has_ledgerhashprevious();
  if (ledgerhashprevious_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerhashprevious_;
    ledgerhashprevious_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMStatusChange::set_allocated_ledgerhashprevious(::std::string* ledgerhashprevious) {
  if (ledgerhashprevious_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhashprevious_;
  }
  if (ledgerhashprevious) {
    set_has_ledgerhashprevious();
    ledgerhashprevious_ = ledgerhashprevious;
  } else {
    clear_has_ledgerhashprevious();
    ledgerhashprevious_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 networkTime = 6;
inline bool TMStatusChange::has_networktime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMStatusChange::set_has_networktime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMStatusChange::clear_has_networktime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMStatusChange::clear_networktime() {
  networktime_ = GOOGLE_ULONGLONG(0);
  clear_has_networktime();
}
inline ::google::protobuf::uint64 TMStatusChange::networktime() const {
  return networktime_;
}
inline void TMStatusChange::set_networktime(::google::protobuf::uint64 value) {
  set_has_networktime();
  networktime_ = value;
}

// optional uint32 firstSeq = 7;
inline bool TMStatusChange::has_firstseq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMStatusChange::set_has_firstseq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMStatusChange::clear_has_firstseq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMStatusChange::clear_firstseq() {
  firstseq_ = 0u;
  clear_has_firstseq();
}
inline ::google::protobuf::uint32 TMStatusChange::firstseq() const {
  return firstseq_;
}
inline void TMStatusChange::set_firstseq(::google::protobuf::uint32 value) {
  set_has_firstseq();
  firstseq_ = value;
}

// optional uint32 lastSeq = 8;
inline bool TMStatusChange::has_lastseq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMStatusChange::set_has_lastseq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMStatusChange::clear_has_lastseq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMStatusChange::clear_lastseq() {
  lastseq_ = 0u;
  clear_has_lastseq();
}
inline ::google::protobuf::uint32 TMStatusChange::lastseq() const {
  return lastseq_;
}
inline void TMStatusChange::set_lastseq(::google::protobuf::uint32 value) {
  set_has_lastseq();
  lastseq_ = value;
}

// -------------------------------------------------------------------

// TMProposeSet

// required uint32 proposeSeq = 1;
inline bool TMProposeSet::has_proposeseq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMProposeSet::set_has_proposeseq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMProposeSet::clear_has_proposeseq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMProposeSet::clear_proposeseq() {
  proposeseq_ = 0u;
  clear_has_proposeseq();
}
inline ::google::protobuf::uint32 TMProposeSet::proposeseq() const {
  return proposeseq_;
}
inline void TMProposeSet::set_proposeseq(::google::protobuf::uint32 value) {
  set_has_proposeseq();
  proposeseq_ = value;
}

// required bytes currentTxHash = 2;
inline bool TMProposeSet::has_currenttxhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMProposeSet::set_has_currenttxhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMProposeSet::clear_has_currenttxhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMProposeSet::clear_currenttxhash() {
  if (currenttxhash_ != &::google::protobuf::internal::kEmptyString) {
    currenttxhash_->clear();
  }
  clear_has_currenttxhash();
}
inline const ::std::string& TMProposeSet::currenttxhash() const {
  return *currenttxhash_;
}
inline void TMProposeSet::set_currenttxhash(const ::std::string& value) {
  set_has_currenttxhash();
  if (currenttxhash_ == &::google::protobuf::internal::kEmptyString) {
    currenttxhash_ = new ::std::string;
  }
  currenttxhash_->assign(value);
}
inline void TMProposeSet::set_currenttxhash(const char* value) {
  set_has_currenttxhash();
  if (currenttxhash_ == &::google::protobuf::internal::kEmptyString) {
    currenttxhash_ = new ::std::string;
  }
  currenttxhash_->assign(value);
}
inline void TMProposeSet::set_currenttxhash(const void* value, size_t size) {
  set_has_currenttxhash();
  if (currenttxhash_ == &::google::protobuf::internal::kEmptyString) {
    currenttxhash_ = new ::std::string;
  }
  currenttxhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProposeSet::mutable_currenttxhash() {
  set_has_currenttxhash();
  if (currenttxhash_ == &::google::protobuf::internal::kEmptyString) {
    currenttxhash_ = new ::std::string;
  }
  return currenttxhash_;
}
inline ::std::string* TMProposeSet::release_currenttxhash() {
  clear_has_currenttxhash();
  if (currenttxhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currenttxhash_;
    currenttxhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProposeSet::set_allocated_currenttxhash(::std::string* currenttxhash) {
  if (currenttxhash_ != &::google::protobuf::internal::kEmptyString) {
    delete currenttxhash_;
  }
  if (currenttxhash) {
    set_has_currenttxhash();
    currenttxhash_ = currenttxhash;
  } else {
    clear_has_currenttxhash();
    currenttxhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes nodePubKey = 3;
inline bool TMProposeSet::has_nodepubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMProposeSet::set_has_nodepubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMProposeSet::clear_has_nodepubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMProposeSet::clear_nodepubkey() {
  if (nodepubkey_ != &::google::protobuf::internal::kEmptyString) {
    nodepubkey_->clear();
  }
  clear_has_nodepubkey();
}
inline const ::std::string& TMProposeSet::nodepubkey() const {
  return *nodepubkey_;
}
inline void TMProposeSet::set_nodepubkey(const ::std::string& value) {
  set_has_nodepubkey();
  if (nodepubkey_ == &::google::protobuf::internal::kEmptyString) {
    nodepubkey_ = new ::std::string;
  }
  nodepubkey_->assign(value);
}
inline void TMProposeSet::set_nodepubkey(const char* value) {
  set_has_nodepubkey();
  if (nodepubkey_ == &::google::protobuf::internal::kEmptyString) {
    nodepubkey_ = new ::std::string;
  }
  nodepubkey_->assign(value);
}
inline void TMProposeSet::set_nodepubkey(const void* value, size_t size) {
  set_has_nodepubkey();
  if (nodepubkey_ == &::google::protobuf::internal::kEmptyString) {
    nodepubkey_ = new ::std::string;
  }
  nodepubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProposeSet::mutable_nodepubkey() {
  set_has_nodepubkey();
  if (nodepubkey_ == &::google::protobuf::internal::kEmptyString) {
    nodepubkey_ = new ::std::string;
  }
  return nodepubkey_;
}
inline ::std::string* TMProposeSet::release_nodepubkey() {
  clear_has_nodepubkey();
  if (nodepubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodepubkey_;
    nodepubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProposeSet::set_allocated_nodepubkey(::std::string* nodepubkey) {
  if (nodepubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete nodepubkey_;
  }
  if (nodepubkey) {
    set_has_nodepubkey();
    nodepubkey_ = nodepubkey;
  } else {
    clear_has_nodepubkey();
    nodepubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 closeTime = 4;
inline bool TMProposeSet::has_closetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMProposeSet::set_has_closetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMProposeSet::clear_has_closetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMProposeSet::clear_closetime() {
  closetime_ = 0u;
  clear_has_closetime();
}
inline ::google::protobuf::uint32 TMProposeSet::closetime() const {
  return closetime_;
}
inline void TMProposeSet::set_closetime(::google::protobuf::uint32 value) {
  set_has_closetime();
  closetime_ = value;
}

// required bytes signature = 5;
inline bool TMProposeSet::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMProposeSet::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMProposeSet::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMProposeSet::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& TMProposeSet::signature() const {
  return *signature_;
}
inline void TMProposeSet::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TMProposeSet::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TMProposeSet::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProposeSet::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* TMProposeSet::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProposeSet::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes previousledger = 6;
inline bool TMProposeSet::has_previousledger() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMProposeSet::set_has_previousledger() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMProposeSet::clear_has_previousledger() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMProposeSet::clear_previousledger() {
  if (previousledger_ != &::google::protobuf::internal::kEmptyString) {
    previousledger_->clear();
  }
  clear_has_previousledger();
}
inline const ::std::string& TMProposeSet::previousledger() const {
  return *previousledger_;
}
inline void TMProposeSet::set_previousledger(const ::std::string& value) {
  set_has_previousledger();
  if (previousledger_ == &::google::protobuf::internal::kEmptyString) {
    previousledger_ = new ::std::string;
  }
  previousledger_->assign(value);
}
inline void TMProposeSet::set_previousledger(const char* value) {
  set_has_previousledger();
  if (previousledger_ == &::google::protobuf::internal::kEmptyString) {
    previousledger_ = new ::std::string;
  }
  previousledger_->assign(value);
}
inline void TMProposeSet::set_previousledger(const void* value, size_t size) {
  set_has_previousledger();
  if (previousledger_ == &::google::protobuf::internal::kEmptyString) {
    previousledger_ = new ::std::string;
  }
  previousledger_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProposeSet::mutable_previousledger() {
  set_has_previousledger();
  if (previousledger_ == &::google::protobuf::internal::kEmptyString) {
    previousledger_ = new ::std::string;
  }
  return previousledger_;
}
inline ::std::string* TMProposeSet::release_previousledger() {
  clear_has_previousledger();
  if (previousledger_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = previousledger_;
    previousledger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMProposeSet::set_allocated_previousledger(::std::string* previousledger) {
  if (previousledger_ != &::google::protobuf::internal::kEmptyString) {
    delete previousledger_;
  }
  if (previousledger) {
    set_has_previousledger();
    previousledger_ = previousledger;
  } else {
    clear_has_previousledger();
    previousledger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool checkedSignature = 7;
inline bool TMProposeSet::has_checkedsignature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMProposeSet::set_has_checkedsignature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMProposeSet::clear_has_checkedsignature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMProposeSet::clear_checkedsignature() {
  checkedsignature_ = false;
  clear_has_checkedsignature();
}
inline bool TMProposeSet::checkedsignature() const {
  return checkedsignature_;
}
inline void TMProposeSet::set_checkedsignature(bool value) {
  set_has_checkedsignature();
  checkedsignature_ = value;
}

// repeated bytes addedTransactions = 10;
inline int TMProposeSet::addedtransactions_size() const {
  return addedtransactions_.size();
}
inline void TMProposeSet::clear_addedtransactions() {
  addedtransactions_.Clear();
}
inline const ::std::string& TMProposeSet::addedtransactions(int index) const {
  return addedtransactions_.Get(index);
}
inline ::std::string* TMProposeSet::mutable_addedtransactions(int index) {
  return addedtransactions_.Mutable(index);
}
inline void TMProposeSet::set_addedtransactions(int index, const ::std::string& value) {
  addedtransactions_.Mutable(index)->assign(value);
}
inline void TMProposeSet::set_addedtransactions(int index, const char* value) {
  addedtransactions_.Mutable(index)->assign(value);
}
inline void TMProposeSet::set_addedtransactions(int index, const void* value, size_t size) {
  addedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProposeSet::add_addedtransactions() {
  return addedtransactions_.Add();
}
inline void TMProposeSet::add_addedtransactions(const ::std::string& value) {
  addedtransactions_.Add()->assign(value);
}
inline void TMProposeSet::add_addedtransactions(const char* value) {
  addedtransactions_.Add()->assign(value);
}
inline void TMProposeSet::add_addedtransactions(const void* value, size_t size) {
  addedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMProposeSet::addedtransactions() const {
  return addedtransactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMProposeSet::mutable_addedtransactions() {
  return &addedtransactions_;
}

// repeated bytes removedTransactions = 11;
inline int TMProposeSet::removedtransactions_size() const {
  return removedtransactions_.size();
}
inline void TMProposeSet::clear_removedtransactions() {
  removedtransactions_.Clear();
}
inline const ::std::string& TMProposeSet::removedtransactions(int index) const {
  return removedtransactions_.Get(index);
}
inline ::std::string* TMProposeSet::mutable_removedtransactions(int index) {
  return removedtransactions_.Mutable(index);
}
inline void TMProposeSet::set_removedtransactions(int index, const ::std::string& value) {
  removedtransactions_.Mutable(index)->assign(value);
}
inline void TMProposeSet::set_removedtransactions(int index, const char* value) {
  removedtransactions_.Mutable(index)->assign(value);
}
inline void TMProposeSet::set_removedtransactions(int index, const void* value, size_t size) {
  removedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMProposeSet::add_removedtransactions() {
  return removedtransactions_.Add();
}
inline void TMProposeSet::add_removedtransactions(const ::std::string& value) {
  removedtransactions_.Add()->assign(value);
}
inline void TMProposeSet::add_removedtransactions(const char* value) {
  removedtransactions_.Add()->assign(value);
}
inline void TMProposeSet::add_removedtransactions(const void* value, size_t size) {
  removedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMProposeSet::removedtransactions() const {
  return removedtransactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMProposeSet::mutable_removedtransactions() {
  return &removedtransactions_;
}

// optional uint32 hops = 12;
inline bool TMProposeSet::has_hops() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TMProposeSet::set_has_hops() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TMProposeSet::clear_has_hops() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TMProposeSet::clear_hops() {
  hops_ = 0u;
  clear_has_hops();
}
inline ::google::protobuf::uint32 TMProposeSet::hops() const {
  return hops_;
}
inline void TMProposeSet::set_hops(::google::protobuf::uint32 value) {
  set_has_hops();
  hops_ = value;
}

// -------------------------------------------------------------------

// TMHaveTransactionSet

// required .protocol.TxSetStatus status = 1;
inline bool TMHaveTransactionSet::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMHaveTransactionSet::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMHaveTransactionSet::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMHaveTransactionSet::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::protocol::TxSetStatus TMHaveTransactionSet::status() const {
  return static_cast< ::protocol::TxSetStatus >(status_);
}
inline void TMHaveTransactionSet::set_status(::protocol::TxSetStatus value) {
  assert(::protocol::TxSetStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required bytes hash = 2;
inline bool TMHaveTransactionSet::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMHaveTransactionSet::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMHaveTransactionSet::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMHaveTransactionSet::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& TMHaveTransactionSet::hash() const {
  return *hash_;
}
inline void TMHaveTransactionSet::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void TMHaveTransactionSet::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void TMHaveTransactionSet::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMHaveTransactionSet::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* TMHaveTransactionSet::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMHaveTransactionSet::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMValidation

// required bytes validation = 1;
inline bool TMValidation::has_validation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMValidation::set_has_validation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMValidation::clear_has_validation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMValidation::clear_validation() {
  if (validation_ != &::google::protobuf::internal::kEmptyString) {
    validation_->clear();
  }
  clear_has_validation();
}
inline const ::std::string& TMValidation::validation() const {
  return *validation_;
}
inline void TMValidation::set_validation(const ::std::string& value) {
  set_has_validation();
  if (validation_ == &::google::protobuf::internal::kEmptyString) {
    validation_ = new ::std::string;
  }
  validation_->assign(value);
}
inline void TMValidation::set_validation(const char* value) {
  set_has_validation();
  if (validation_ == &::google::protobuf::internal::kEmptyString) {
    validation_ = new ::std::string;
  }
  validation_->assign(value);
}
inline void TMValidation::set_validation(const void* value, size_t size) {
  set_has_validation();
  if (validation_ == &::google::protobuf::internal::kEmptyString) {
    validation_ = new ::std::string;
  }
  validation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMValidation::mutable_validation() {
  set_has_validation();
  if (validation_ == &::google::protobuf::internal::kEmptyString) {
    validation_ = new ::std::string;
  }
  return validation_;
}
inline ::std::string* TMValidation::release_validation() {
  clear_has_validation();
  if (validation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = validation_;
    validation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMValidation::set_allocated_validation(::std::string* validation) {
  if (validation_ != &::google::protobuf::internal::kEmptyString) {
    delete validation_;
  }
  if (validation) {
    set_has_validation();
    validation_ = validation;
  } else {
    clear_has_validation();
    validation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool checkedSignature = 2;
inline bool TMValidation::has_checkedsignature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMValidation::set_has_checkedsignature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMValidation::clear_has_checkedsignature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMValidation::clear_checkedsignature() {
  checkedsignature_ = false;
  clear_has_checkedsignature();
}
inline bool TMValidation::checkedsignature() const {
  return checkedsignature_;
}
inline void TMValidation::set_checkedsignature(bool value) {
  set_has_checkedsignature();
  checkedsignature_ = value;
}

// optional uint32 hops = 3;
inline bool TMValidation::has_hops() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMValidation::set_has_hops() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMValidation::clear_has_hops() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMValidation::clear_hops() {
  hops_ = 0u;
  clear_has_hops();
}
inline ::google::protobuf::uint32 TMValidation::hops() const {
  return hops_;
}
inline void TMValidation::set_hops(::google::protobuf::uint32 value) {
  set_has_hops();
  hops_ = value;
}

// -------------------------------------------------------------------

// TMGetPeers

// required uint32 doWeNeedThis = 1;
inline bool TMGetPeers::has_doweneedthis() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMGetPeers::set_has_doweneedthis() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMGetPeers::clear_has_doweneedthis() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMGetPeers::clear_doweneedthis() {
  doweneedthis_ = 0u;
  clear_has_doweneedthis();
}
inline ::google::protobuf::uint32 TMGetPeers::doweneedthis() const {
  return doweneedthis_;
}
inline void TMGetPeers::set_doweneedthis(::google::protobuf::uint32 value) {
  set_has_doweneedthis();
  doweneedthis_ = value;
}

// -------------------------------------------------------------------

// TMIPv4Endpoint

// required uint32 ipv4 = 1;
inline bool TMIPv4Endpoint::has_ipv4() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMIPv4Endpoint::set_has_ipv4() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMIPv4Endpoint::clear_has_ipv4() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMIPv4Endpoint::clear_ipv4() {
  ipv4_ = 0u;
  clear_has_ipv4();
}
inline ::google::protobuf::uint32 TMIPv4Endpoint::ipv4() const {
  return ipv4_;
}
inline void TMIPv4Endpoint::set_ipv4(::google::protobuf::uint32 value) {
  set_has_ipv4();
  ipv4_ = value;
}

// required uint32 ipv4Port = 2;
inline bool TMIPv4Endpoint::has_ipv4port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMIPv4Endpoint::set_has_ipv4port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMIPv4Endpoint::clear_has_ipv4port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMIPv4Endpoint::clear_ipv4port() {
  ipv4port_ = 0u;
  clear_has_ipv4port();
}
inline ::google::protobuf::uint32 TMIPv4Endpoint::ipv4port() const {
  return ipv4port_;
}
inline void TMIPv4Endpoint::set_ipv4port(::google::protobuf::uint32 value) {
  set_has_ipv4port();
  ipv4port_ = value;
}

// -------------------------------------------------------------------

// TMPeers

// repeated .protocol.TMIPv4Endpoint nodes = 1;
inline int TMPeers::nodes_size() const {
  return nodes_.size();
}
inline void TMPeers::clear_nodes() {
  nodes_.Clear();
}
inline const ::protocol::TMIPv4Endpoint& TMPeers::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::protocol::TMIPv4Endpoint* TMPeers::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::protocol::TMIPv4Endpoint* TMPeers::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMIPv4Endpoint >&
TMPeers::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TMIPv4Endpoint >*
TMPeers::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// TMEndpoint

// required .protocol.TMIPv4Endpoint ipv4 = 1;
inline bool TMEndpoint::has_ipv4() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMEndpoint::set_has_ipv4() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMEndpoint::clear_has_ipv4() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMEndpoint::clear_ipv4() {
  if (ipv4_ != NULL) ipv4_->::protocol::TMIPv4Endpoint::Clear();
  clear_has_ipv4();
}
inline const ::protocol::TMIPv4Endpoint& TMEndpoint::ipv4() const {
  return ipv4_ != NULL ? *ipv4_ : *default_instance_->ipv4_;
}
inline ::protocol::TMIPv4Endpoint* TMEndpoint::mutable_ipv4() {
  set_has_ipv4();
  if (ipv4_ == NULL) ipv4_ = new ::protocol::TMIPv4Endpoint;
  return ipv4_;
}
inline ::protocol::TMIPv4Endpoint* TMEndpoint::release_ipv4() {
  clear_has_ipv4();
  ::protocol::TMIPv4Endpoint* temp = ipv4_;
  ipv4_ = NULL;
  return temp;
}
inline void TMEndpoint::set_allocated_ipv4(::protocol::TMIPv4Endpoint* ipv4) {
  delete ipv4_;
  ipv4_ = ipv4;
  if (ipv4) {
    set_has_ipv4();
  } else {
    clear_has_ipv4();
  }
}

// required uint32 hops = 2;
inline bool TMEndpoint::has_hops() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMEndpoint::set_has_hops() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMEndpoint::clear_has_hops() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMEndpoint::clear_hops() {
  hops_ = 0u;
  clear_has_hops();
}
inline ::google::protobuf::uint32 TMEndpoint::hops() const {
  return hops_;
}
inline void TMEndpoint::set_hops(::google::protobuf::uint32 value) {
  set_has_hops();
  hops_ = value;
}

// -------------------------------------------------------------------

// TMEndpoints

// required uint32 version = 1;
inline bool TMEndpoints::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMEndpoints::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMEndpoints::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMEndpoints::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TMEndpoints::version() const {
  return version_;
}
inline void TMEndpoints::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// repeated .protocol.TMEndpoint endpoints = 2;
inline int TMEndpoints::endpoints_size() const {
  return endpoints_.size();
}
inline void TMEndpoints::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::protocol::TMEndpoint& TMEndpoints::endpoints(int index) const {
  return endpoints_.Get(index);
}
inline ::protocol::TMEndpoint* TMEndpoints::mutable_endpoints(int index) {
  return endpoints_.Mutable(index);
}
inline ::protocol::TMEndpoint* TMEndpoints::add_endpoints() {
  return endpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMEndpoint >&
TMEndpoints::endpoints() const {
  return endpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TMEndpoint >*
TMEndpoints::mutable_endpoints() {
  return &endpoints_;
}

// -------------------------------------------------------------------

// TMIndexedObject

// optional bytes hash = 1;
inline bool TMIndexedObject::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMIndexedObject::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMIndexedObject::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMIndexedObject::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& TMIndexedObject::hash() const {
  return *hash_;
}
inline void TMIndexedObject::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void TMIndexedObject::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void TMIndexedObject::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMIndexedObject::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* TMIndexedObject::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMIndexedObject::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nodeID = 2;
inline bool TMIndexedObject::has_nodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMIndexedObject::set_has_nodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMIndexedObject::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMIndexedObject::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& TMIndexedObject::nodeid() const {
  return *nodeid_;
}
inline void TMIndexedObject::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void TMIndexedObject::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void TMIndexedObject::set_nodeid(const void* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMIndexedObject::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* TMIndexedObject::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMIndexedObject::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    delete nodeid_;
  }
  if (nodeid) {
    set_has_nodeid();
    nodeid_ = nodeid;
  } else {
    clear_has_nodeid();
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes index = 3;
inline bool TMIndexedObject::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMIndexedObject::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMIndexedObject::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMIndexedObject::clear_index() {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& TMIndexedObject::index() const {
  return *index_;
}
inline void TMIndexedObject::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void TMIndexedObject::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void TMIndexedObject::set_index(const void* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMIndexedObject::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  return index_;
}
inline ::std::string* TMIndexedObject::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMIndexedObject::set_allocated_index(::std::string* index) {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    delete index_;
  }
  if (index) {
    set_has_index();
    index_ = index;
  } else {
    clear_has_index();
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 4;
inline bool TMIndexedObject::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMIndexedObject::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMIndexedObject::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMIndexedObject::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TMIndexedObject::data() const {
  return *data_;
}
inline void TMIndexedObject::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TMIndexedObject::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TMIndexedObject::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMIndexedObject::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TMIndexedObject::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMIndexedObject::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ledgerSeq = 5;
inline bool TMIndexedObject::has_ledgerseq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMIndexedObject::set_has_ledgerseq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMIndexedObject::clear_has_ledgerseq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMIndexedObject::clear_ledgerseq() {
  ledgerseq_ = 0u;
  clear_has_ledgerseq();
}
inline ::google::protobuf::uint32 TMIndexedObject::ledgerseq() const {
  return ledgerseq_;
}
inline void TMIndexedObject::set_ledgerseq(::google::protobuf::uint32 value) {
  set_has_ledgerseq();
  ledgerseq_ = value;
}

// -------------------------------------------------------------------

// TMGetObjectByHash

// required .protocol.TMGetObjectByHash.ObjectType type = 1;
inline bool TMGetObjectByHash::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMGetObjectByHash::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMGetObjectByHash::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMGetObjectByHash::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::TMGetObjectByHash_ObjectType TMGetObjectByHash::type() const {
  return static_cast< ::protocol::TMGetObjectByHash_ObjectType >(type_);
}
inline void TMGetObjectByHash::set_type(::protocol::TMGetObjectByHash_ObjectType value) {
  assert(::protocol::TMGetObjectByHash_ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bool query = 2;
inline bool TMGetObjectByHash::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMGetObjectByHash::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMGetObjectByHash::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMGetObjectByHash::clear_query() {
  query_ = false;
  clear_has_query();
}
inline bool TMGetObjectByHash::query() const {
  return query_;
}
inline void TMGetObjectByHash::set_query(bool value) {
  set_has_query();
  query_ = value;
}

// optional uint32 seq = 3;
inline bool TMGetObjectByHash::has_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMGetObjectByHash::set_has_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMGetObjectByHash::clear_has_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMGetObjectByHash::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 TMGetObjectByHash::seq() const {
  return seq_;
}
inline void TMGetObjectByHash::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// optional bytes ledgerHash = 4;
inline bool TMGetObjectByHash::has_ledgerhash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMGetObjectByHash::set_has_ledgerhash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMGetObjectByHash::clear_has_ledgerhash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMGetObjectByHash::clear_ledgerhash() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    ledgerhash_->clear();
  }
  clear_has_ledgerhash();
}
inline const ::std::string& TMGetObjectByHash::ledgerhash() const {
  return *ledgerhash_;
}
inline void TMGetObjectByHash::set_ledgerhash(const ::std::string& value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMGetObjectByHash::set_ledgerhash(const char* value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMGetObjectByHash::set_ledgerhash(const void* value, size_t size) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMGetObjectByHash::mutable_ledgerhash() {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  return ledgerhash_;
}
inline ::std::string* TMGetObjectByHash::release_ledgerhash() {
  clear_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerhash_;
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMGetObjectByHash::set_allocated_ledgerhash(::std::string* ledgerhash) {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (ledgerhash) {
    set_has_ledgerhash();
    ledgerhash_ = ledgerhash;
  } else {
    clear_has_ledgerhash();
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool fat = 5;
inline bool TMGetObjectByHash::has_fat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMGetObjectByHash::set_has_fat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMGetObjectByHash::clear_has_fat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMGetObjectByHash::clear_fat() {
  fat_ = false;
  clear_has_fat();
}
inline bool TMGetObjectByHash::fat() const {
  return fat_;
}
inline void TMGetObjectByHash::set_fat(bool value) {
  set_has_fat();
  fat_ = value;
}

// repeated .protocol.TMIndexedObject objects = 6;
inline int TMGetObjectByHash::objects_size() const {
  return objects_.size();
}
inline void TMGetObjectByHash::clear_objects() {
  objects_.Clear();
}
inline const ::protocol::TMIndexedObject& TMGetObjectByHash::objects(int index) const {
  return objects_.Get(index);
}
inline ::protocol::TMIndexedObject* TMGetObjectByHash::mutable_objects(int index) {
  return objects_.Mutable(index);
}
inline ::protocol::TMIndexedObject* TMGetObjectByHash::add_objects() {
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMIndexedObject >&
TMGetObjectByHash::objects() const {
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TMIndexedObject >*
TMGetObjectByHash::mutable_objects() {
  return &objects_;
}

// -------------------------------------------------------------------

// TMLedgerNode

// required bytes nodedata = 1;
inline bool TMLedgerNode::has_nodedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMLedgerNode::set_has_nodedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMLedgerNode::clear_has_nodedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMLedgerNode::clear_nodedata() {
  if (nodedata_ != &::google::protobuf::internal::kEmptyString) {
    nodedata_->clear();
  }
  clear_has_nodedata();
}
inline const ::std::string& TMLedgerNode::nodedata() const {
  return *nodedata_;
}
inline void TMLedgerNode::set_nodedata(const ::std::string& value) {
  set_has_nodedata();
  if (nodedata_ == &::google::protobuf::internal::kEmptyString) {
    nodedata_ = new ::std::string;
  }
  nodedata_->assign(value);
}
inline void TMLedgerNode::set_nodedata(const char* value) {
  set_has_nodedata();
  if (nodedata_ == &::google::protobuf::internal::kEmptyString) {
    nodedata_ = new ::std::string;
  }
  nodedata_->assign(value);
}
inline void TMLedgerNode::set_nodedata(const void* value, size_t size) {
  set_has_nodedata();
  if (nodedata_ == &::google::protobuf::internal::kEmptyString) {
    nodedata_ = new ::std::string;
  }
  nodedata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMLedgerNode::mutable_nodedata() {
  set_has_nodedata();
  if (nodedata_ == &::google::protobuf::internal::kEmptyString) {
    nodedata_ = new ::std::string;
  }
  return nodedata_;
}
inline ::std::string* TMLedgerNode::release_nodedata() {
  clear_has_nodedata();
  if (nodedata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodedata_;
    nodedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMLedgerNode::set_allocated_nodedata(::std::string* nodedata) {
  if (nodedata_ != &::google::protobuf::internal::kEmptyString) {
    delete nodedata_;
  }
  if (nodedata) {
    set_has_nodedata();
    nodedata_ = nodedata;
  } else {
    clear_has_nodedata();
    nodedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nodeid = 2;
inline bool TMLedgerNode::has_nodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMLedgerNode::set_has_nodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMLedgerNode::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMLedgerNode::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& TMLedgerNode::nodeid() const {
  return *nodeid_;
}
inline void TMLedgerNode::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void TMLedgerNode::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void TMLedgerNode::set_nodeid(const void* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMLedgerNode::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* TMLedgerNode::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMLedgerNode::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    delete nodeid_;
  }
  if (nodeid) {
    set_has_nodeid();
    nodeid_ = nodeid;
  } else {
    clear_has_nodeid();
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TMGetLedger

// required .protocol.TMLedgerInfoType itype = 1;
inline bool TMGetLedger::has_itype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMGetLedger::set_has_itype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMGetLedger::clear_has_itype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMGetLedger::clear_itype() {
  itype_ = 0;
  clear_has_itype();
}
inline ::protocol::TMLedgerInfoType TMGetLedger::itype() const {
  return static_cast< ::protocol::TMLedgerInfoType >(itype_);
}
inline void TMGetLedger::set_itype(::protocol::TMLedgerInfoType value) {
  assert(::protocol::TMLedgerInfoType_IsValid(value));
  set_has_itype();
  itype_ = value;
}

// optional .protocol.TMLedgerType ltype = 2;
inline bool TMGetLedger::has_ltype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMGetLedger::set_has_ltype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMGetLedger::clear_has_ltype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMGetLedger::clear_ltype() {
  ltype_ = 0;
  clear_has_ltype();
}
inline ::protocol::TMLedgerType TMGetLedger::ltype() const {
  return static_cast< ::protocol::TMLedgerType >(ltype_);
}
inline void TMGetLedger::set_ltype(::protocol::TMLedgerType value) {
  assert(::protocol::TMLedgerType_IsValid(value));
  set_has_ltype();
  ltype_ = value;
}

// optional bytes ledgerHash = 3;
inline bool TMGetLedger::has_ledgerhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMGetLedger::set_has_ledgerhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMGetLedger::clear_has_ledgerhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMGetLedger::clear_ledgerhash() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    ledgerhash_->clear();
  }
  clear_has_ledgerhash();
}
inline const ::std::string& TMGetLedger::ledgerhash() const {
  return *ledgerhash_;
}
inline void TMGetLedger::set_ledgerhash(const ::std::string& value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMGetLedger::set_ledgerhash(const char* value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMGetLedger::set_ledgerhash(const void* value, size_t size) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMGetLedger::mutable_ledgerhash() {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  return ledgerhash_;
}
inline ::std::string* TMGetLedger::release_ledgerhash() {
  clear_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerhash_;
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMGetLedger::set_allocated_ledgerhash(::std::string* ledgerhash) {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (ledgerhash) {
    set_has_ledgerhash();
    ledgerhash_ = ledgerhash;
  } else {
    clear_has_ledgerhash();
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ledgerSeq = 4;
inline bool TMGetLedger::has_ledgerseq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMGetLedger::set_has_ledgerseq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMGetLedger::clear_has_ledgerseq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMGetLedger::clear_ledgerseq() {
  ledgerseq_ = 0u;
  clear_has_ledgerseq();
}
inline ::google::protobuf::uint32 TMGetLedger::ledgerseq() const {
  return ledgerseq_;
}
inline void TMGetLedger::set_ledgerseq(::google::protobuf::uint32 value) {
  set_has_ledgerseq();
  ledgerseq_ = value;
}

// repeated bytes nodeIDs = 5;
inline int TMGetLedger::nodeids_size() const {
  return nodeids_.size();
}
inline void TMGetLedger::clear_nodeids() {
  nodeids_.Clear();
}
inline const ::std::string& TMGetLedger::nodeids(int index) const {
  return nodeids_.Get(index);
}
inline ::std::string* TMGetLedger::mutable_nodeids(int index) {
  return nodeids_.Mutable(index);
}
inline void TMGetLedger::set_nodeids(int index, const ::std::string& value) {
  nodeids_.Mutable(index)->assign(value);
}
inline void TMGetLedger::set_nodeids(int index, const char* value) {
  nodeids_.Mutable(index)->assign(value);
}
inline void TMGetLedger::set_nodeids(int index, const void* value, size_t size) {
  nodeids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMGetLedger::add_nodeids() {
  return nodeids_.Add();
}
inline void TMGetLedger::add_nodeids(const ::std::string& value) {
  nodeids_.Add()->assign(value);
}
inline void TMGetLedger::add_nodeids(const char* value) {
  nodeids_.Add()->assign(value);
}
inline void TMGetLedger::add_nodeids(const void* value, size_t size) {
  nodeids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TMGetLedger::nodeids() const {
  return nodeids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TMGetLedger::mutable_nodeids() {
  return &nodeids_;
}

// optional uint64 requestCookie = 6;
inline bool TMGetLedger::has_requestcookie() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMGetLedger::set_has_requestcookie() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMGetLedger::clear_has_requestcookie() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMGetLedger::clear_requestcookie() {
  requestcookie_ = GOOGLE_ULONGLONG(0);
  clear_has_requestcookie();
}
inline ::google::protobuf::uint64 TMGetLedger::requestcookie() const {
  return requestcookie_;
}
inline void TMGetLedger::set_requestcookie(::google::protobuf::uint64 value) {
  set_has_requestcookie();
  requestcookie_ = value;
}

// optional .protocol.TMQueryType queryType = 7;
inline bool TMGetLedger::has_querytype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TMGetLedger::set_has_querytype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TMGetLedger::clear_has_querytype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TMGetLedger::clear_querytype() {
  querytype_ = 0;
  clear_has_querytype();
}
inline ::protocol::TMQueryType TMGetLedger::querytype() const {
  return static_cast< ::protocol::TMQueryType >(querytype_);
}
inline void TMGetLedger::set_querytype(::protocol::TMQueryType value) {
  assert(::protocol::TMQueryType_IsValid(value));
  set_has_querytype();
  querytype_ = value;
}

// optional uint32 queryDepth = 8;
inline bool TMGetLedger::has_querydepth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TMGetLedger::set_has_querydepth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TMGetLedger::clear_has_querydepth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TMGetLedger::clear_querydepth() {
  querydepth_ = 0u;
  clear_has_querydepth();
}
inline ::google::protobuf::uint32 TMGetLedger::querydepth() const {
  return querydepth_;
}
inline void TMGetLedger::set_querydepth(::google::protobuf::uint32 value) {
  set_has_querydepth();
  querydepth_ = value;
}

// -------------------------------------------------------------------

// TMLedgerData

// required bytes ledgerHash = 1;
inline bool TMLedgerData::has_ledgerhash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMLedgerData::set_has_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMLedgerData::clear_has_ledgerhash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMLedgerData::clear_ledgerhash() {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    ledgerhash_->clear();
  }
  clear_has_ledgerhash();
}
inline const ::std::string& TMLedgerData::ledgerhash() const {
  return *ledgerhash_;
}
inline void TMLedgerData::set_ledgerhash(const ::std::string& value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMLedgerData::set_ledgerhash(const char* value) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(value);
}
inline void TMLedgerData::set_ledgerhash(const void* value, size_t size) {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  ledgerhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMLedgerData::mutable_ledgerhash() {
  set_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    ledgerhash_ = new ::std::string;
  }
  return ledgerhash_;
}
inline ::std::string* TMLedgerData::release_ledgerhash() {
  clear_has_ledgerhash();
  if (ledgerhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ledgerhash_;
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMLedgerData::set_allocated_ledgerhash(::std::string* ledgerhash) {
  if (ledgerhash_ != &::google::protobuf::internal::kEmptyString) {
    delete ledgerhash_;
  }
  if (ledgerhash) {
    set_has_ledgerhash();
    ledgerhash_ = ledgerhash;
  } else {
    clear_has_ledgerhash();
    ledgerhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ledgerSeq = 2;
inline bool TMLedgerData::has_ledgerseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMLedgerData::set_has_ledgerseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMLedgerData::clear_has_ledgerseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMLedgerData::clear_ledgerseq() {
  ledgerseq_ = 0u;
  clear_has_ledgerseq();
}
inline ::google::protobuf::uint32 TMLedgerData::ledgerseq() const {
  return ledgerseq_;
}
inline void TMLedgerData::set_ledgerseq(::google::protobuf::uint32 value) {
  set_has_ledgerseq();
  ledgerseq_ = value;
}

// required .protocol.TMLedgerInfoType type = 3;
inline bool TMLedgerData::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMLedgerData::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMLedgerData::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMLedgerData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::TMLedgerInfoType TMLedgerData::type() const {
  return static_cast< ::protocol::TMLedgerInfoType >(type_);
}
inline void TMLedgerData::set_type(::protocol::TMLedgerInfoType value) {
  assert(::protocol::TMLedgerInfoType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .protocol.TMLedgerNode nodes = 4;
inline int TMLedgerData::nodes_size() const {
  return nodes_.size();
}
inline void TMLedgerData::clear_nodes() {
  nodes_.Clear();
}
inline const ::protocol::TMLedgerNode& TMLedgerData::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::protocol::TMLedgerNode* TMLedgerData::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::protocol::TMLedgerNode* TMLedgerData::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TMLedgerNode >&
TMLedgerData::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TMLedgerNode >*
TMLedgerData::mutable_nodes() {
  return &nodes_;
}

// optional uint32 requestCookie = 5;
inline bool TMLedgerData::has_requestcookie() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TMLedgerData::set_has_requestcookie() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TMLedgerData::clear_has_requestcookie() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TMLedgerData::clear_requestcookie() {
  requestcookie_ = 0u;
  clear_has_requestcookie();
}
inline ::google::protobuf::uint32 TMLedgerData::requestcookie() const {
  return requestcookie_;
}
inline void TMLedgerData::set_requestcookie(::google::protobuf::uint32 value) {
  set_has_requestcookie();
  requestcookie_ = value;
}

// optional .protocol.TMReplyError error = 6;
inline bool TMLedgerData::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TMLedgerData::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TMLedgerData::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TMLedgerData::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::protocol::TMReplyError TMLedgerData::error() const {
  return static_cast< ::protocol::TMReplyError >(error_);
}
inline void TMLedgerData::set_error(::protocol::TMReplyError value) {
  assert(::protocol::TMReplyError_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// TMPing

// required .protocol.TMPing.pingType type = 1;
inline bool TMPing::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMPing::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMPing::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMPing::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::TMPing_pingType TMPing::type() const {
  return static_cast< ::protocol::TMPing_pingType >(type_);
}
inline void TMPing::set_type(::protocol::TMPing_pingType value) {
  assert(::protocol::TMPing_pingType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 seq = 2;
inline bool TMPing::has_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMPing::set_has_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMPing::clear_has_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMPing::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 TMPing::seq() const {
  return seq_;
}
inline void TMPing::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// optional uint64 pingTime = 3;
inline bool TMPing::has_pingtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMPing::set_has_pingtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMPing::clear_has_pingtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMPing::clear_pingtime() {
  pingtime_ = GOOGLE_ULONGLONG(0);
  clear_has_pingtime();
}
inline ::google::protobuf::uint64 TMPing::pingtime() const {
  return pingtime_;
}
inline void TMPing::set_pingtime(::google::protobuf::uint64 value) {
  set_has_pingtime();
  pingtime_ = value;
}

// optional uint64 netTime = 4;
inline bool TMPing::has_nettime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMPing::set_has_nettime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMPing::clear_has_nettime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMPing::clear_nettime() {
  nettime_ = GOOGLE_ULONGLONG(0);
  clear_has_nettime();
}
inline ::google::protobuf::uint64 TMPing::nettime() const {
  return nettime_;
}
inline void TMPing::set_nettime(::google::protobuf::uint64 value) {
  set_has_nettime();
  nettime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMProofWork_PowResult>() {
  return ::protocol::TMProofWork_PowResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMGetObjectByHash_ObjectType>() {
  return ::protocol::TMGetObjectByHash_ObjectType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMPing_pingType>() {
  return ::protocol::TMPing_pingType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::MessageType>() {
  return ::protocol::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TransactionStatus>() {
  return ::protocol::TransactionStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NodeStatus>() {
  return ::protocol::NodeStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NodeEvent>() {
  return ::protocol::NodeEvent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TxSetStatus>() {
  return ::protocol::TxSetStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMLedgerInfoType>() {
  return ::protocol::TMLedgerInfoType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMLedgerType>() {
  return ::protocol::TMLedgerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMQueryType>() {
  return ::protocol::TMQueryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMReplyError>() {
  return ::protocol::TMReplyError_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_skywell_2eproto__INCLUDED
